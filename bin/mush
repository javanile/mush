#!/usr/bin/env bash
# @BP010: Release metadata
# @package: mush
# @build_type: bin
# @build_with: inject file VERSION
# @build_date: 2025-05-17T21:54:29Z
set -e
use() { return 0; }
extern() { return 0; }
legacy() { return 0; }
module() { return 0; }
public() { return 0; }
embed() { return 0; }
inject() { return 0; }
## BP004: Compile the entrypoint
# @score: 10

extern package console
extern package getoptions

module api
module build
module collections
module color
module commands
module errors
module features
module package_managers
module registry
module tasks
module env
module polyfill

embed global

parser_definition() {
  setup REST error:args_error help:usage abbr:true -- "Shell's build system" ''

  msg   -- 'USAGE:' "  ${2##*/} [OPTIONS] [SUBCOMMAND]" ''

  msg   -- 'OPTIONS:'
  disp  VERSION     -V --version                      -- "Print version info and exit"
  param PRINT          --print                        -- "Builder information to print on stdout"
  param EXPLAIN        --explain                      -- "Provide a detailed explanation of an error message"
  flag  VERBOSE     -v --verbose counter:true init:=0 -- "Use verbose output (-vv or -vvv to increase level)"
  flag  QUIET       -q --quiet                        -- "Do not print cargo log messages"
  disp  :usage      -h --help                         -- "Print help information"

  msg           -- '' "See '${2##*/} <command> --help' for more information on a specific command."
  cmd   build   -- "Compile the current package"
  cmd   check   -- "Analyze the current package and report errors, but don't build it"
  cmd   fetch   -- "Fetch dependencies of a package from the network"
  cmd   init    -- "Create a new package in an existing directory"
  cmd   install -- "Build and install a Mush binary"
  cmd   legacy  -- "Add legacy dependencies to a Manifest.toml file"
  cmd   new     -- "Create a new Mush package"
  cmd   run     -- "Run a binary or example of the local package"
  cmd   test    -- "Run the tests"
  cmd   search  -- "Search registry for packages"
  cmd   publish -- "Package and upload this package to the registry"

  cmd   metadata hidden:true -- "Print package metadata"
  cmd   info     hidden:true -- "Show information of a package in the registry"
  cmd   index    hidden:true -- "Display index of to the registry"
}

args_error() {
  case "$2" in
    notcmd)
      console_error "no such command: '$3'\n\n\tView all available commands with 'mush --help'"
      ;;
    required)
      console_error "argument to option '$3' missing."
      ;;
    *)
      echo "ERROR: ($2 $3) $1"
  esac
  exit 101
}

main() {
  if [ $# -eq 0 ]; then
    eval "set -- --help"
  fi

  if [ -n "${MUSH_DEBUG_TRACE}" ]; then
    set -x
  fi

  VERSION=$(global VERSION)

  eval "$(getoptions parser_definition parse "$0") exit 1"
  parse "$@"
  eval "set -- $REST"

  [ "${VERBOSE}" -gt 1 ] && console_info "Version" "${VERSION}"
  [ "${VERBOSE}" -gt 2 ] && console_info "Verbosity" "level=${VERBOSE}"
  [ "${VERBOSE}" -gt 3 ] && console_info "Directory" "home=${MUSH_HOME} pwd=${PWD}"

  if [ -n "${PRINT}" ]; then
    mush_build_print "${PRINT}"
  elif [ -n "${EXPLAIN}" ]; then
    mush_errors_explain "${EXPLAIN}"
  elif [ $# -gt 0 ]; then
    cmd=$1
    shift
    case $cmd in
      build)
        run_build "$@"
        ;;
      check)
        run_check "$@"
        ;;
      fetch)
        run_fetch "$@"
        ;;
      init)
        run_init "$@"
        ;;
      install)
        run_install "$@"
        ;;
      legacy)
        run_legacy "$@"
        ;;
      new)
        run_new "$@"
        ;;
      run)
        run_run "$@"
        ;;
      test)
        run_test "$@"
        ;;
      publish)
        run_publish "$@"
        ;;
      metadata)
        run_metadata "$@"
        ;;
      read-manifest)
        run_read_manifest "$@"
        ;;
      search)
        run_search "$@"
        ;;
      pkgid)
        run_pkgid "$@"
        ;;
      index)
        run_index "$@"
        ;;
      info)
        run_info "$@"
        ;;
      --) # no subcommand, arguments only
    esac
  fi
}

embed debug_2022
embed release_2022
embed test_2022

public embed_2022

mush_api_2022_embed() {
  local module_name
  local module_file
  local inject_type
  local inject_name
  local inject_file
  local inject_data

  module_name=$1
  module_file=$2

  echo "${module_name}() {"

  echo "  if [ -z \"\$1\" ]; then"
  echo "    cat <<'EMBED'"
  #cat "$module_file" | tr -s '\n'
  sed '/^[[:space:]]*$/d' "${module_file}"
  echo "EMBED"

  echo "  else"

  echo "    case \"\$1\" in"
  grep -n '^inject [a-z][a-z]* [a-zA-Z0-9][a-zA-Z0-9_\.]*$' "${module_file}" | while read -r line; do
    inject_type=$(echo "${line#*inject}" | awk '{print $1}')
    inject_name=$(echo "${line#*inject}" | awk '{print $2}')
    echo "      ${inject_name})"
    case "${inject_type}" in
      file)
        inject_file="$(dirname "${module_file}")/${inject_name}"
        echo "        cat <<'EMBED'"
        cat "$inject_file"
        echo ""
        echo "EMBED"
        ;;
      env)
        eval inject_data="\$$inject_name"
        echo "        echo \"$inject_data\""
        ;;
      *)
        echo "ERROR: Unknown inject type '${inject_type}' in line '${line}'"
        exit 101
        ;;
    esac
    echo "        ;;"
  done
  echo "      *)"
  echo "        echo \"${inject_type}: ${inject_name}\""
  echo "        ;;"
  echo "    esac"

  echo "  fi"


  echo "}"
}
debug_2022() {
  if [ -z "$1" ]; then
    cat <<'EMBED'
debug() {
  local api
  api=$1
  case "${api}" in
    init)
      extern() {
        local debug_file=$MUSH_DEBUG_FILE
        if [ "$1" = "package" ]; then
          local package_name=$MUSH_PACKAGE_NAME
          local extern_package_name=$2
          local extern_package_path="${MUSH_DEBUG_PATH}/${MUSH_TARGET_PATH}/packages/${extern_package_name}"
          local extern_package_lib_file="${MUSH_DEBUG_PATH}/${MUSH_TARGET_PATH}/packages/${extern_package_name}/lib.sh"
          if [ -d "${extern_package_path}" ]; then
            debug file "${extern_package_lib_file}"
            debug init
          else
            echo "   Compiling rust-app v0.1.0 (/home/francesco/Develop/Javanile/mush/tests/fixtures/rust-app)"
            error_package_not_found "${extern_package_name}" "${debug_file}"
            exit 1
          fi
        else
          echo "   Compiling rust-app v0.1.0 (/home/francesco/Develop/Javanile/mush/tests/fixtures/rust-app)"
          echo "error: expected one of 'package' or '{', found '$1'"
          echo " --> ${debug_file}:8:8"
          echo "  |"
          echo "8 | extern cavallo json;"
          echo "  |        ^^^^^^^ expected one of 'package' or '{'"
          echo ""
          echo "error: could not compile '${package_name}' due to previous error"
          exit 1
        fi
      }
      legacy() {
        local legacy_file="target/debug/legacy/__$1.sh"
        local legacy_file_path="${MUSH_DEBUG_PATH}/${legacy_file}"
        if [ ! -f "$legacy_file_path" ]; then
          echo "File not found '${legacy_file}', type 'mush build' to recover this problem." >&2
          exit 101
        fi
        . "${legacy_file_path}"
      }
      module() {
        local module_name=$1
        local module_file="src/$1.sh"
        local module_file_path="${MUSH_DEBUG_PATH}/${module_file}"
        local module_dir_file="src/$1/module.sh"
        local module_dir_file_path="${MUSH_DEBUG_PATH}/${module_dir_file}"
        local debug_file=$MUSH_DEBUG_FILE
        local package_name=$MUSH_PACKAGE_NAME
        if [ -f "${module_file_path}" ]; then
          . "${module_file_path}"
        elif [ -f "${module_dir_file_path}" ]; then
          MUSH_RUNTIME_MODULE=$1
          . "${module_dir_file_path}"
        else
          console_error_code E0583 "file not found for module '${module_name}'"
          [ "${VERBOSE}" -gt 6 ] && echo "File not found: ${module_file_path} (package_dir: ${extern_package_dir})"
          echo " --> ${debug_file}:4:1"
          echo "  |"
          echo "4 | mod notfound;"
          echo "  | ^^^^^^^^^^^^^"
          echo "  |"
          echo "  = help: to create the module '${module_name}', create file 'src/${module_name}.sh' or 'src/${module_name}/module.sh'"
          echo ""
          echo "For more information about this error, try 'mush explain E0583'."
          echo "error: could not compile '${package_name}' due to previous error"
          exit 1
        fi
      }
      public() {
        local module_file="src/$MUSH_RUNTIME_MODULE/$1.sh"
        local module_file_path="${MUSH_DEBUG_PATH}/${module_file}"
        local module_dir_file="src/$MUSH_RUNTIME_MODULE/$1/module.sh"
        local module_dir_file_path="${MUSH_DEBUG_PATH}/${module_dir_file}"
        if [ -f "${module_file_path}" ]; then
          . "${module_file_path}"
        elif [ -f "${module_dir_file_path}" ]; then
          . "${module_dir_file_path}"
        else
          echo "Public module not found: '${module_file_path}' or '${module_dir_file_path}'." >&2
          exit 101
        fi
      }
      use() {
        return 0
      }
      embed() {
        local module_file="src/${MUSH_RUNTIME_MODULE}/$1.sh"
        local module_file_path="${MUSH_DEBUG_PATH}/${module_file}"
        eval "$(mush_api_2022_embed "$1" "${module_file_path}")"
      }
      inject() {
        return 0
      }
      ;;
    file)
      local previous_debug_file=$MUSH_DEBUG_FILE
      MUSH_DEBUG_FILE=$2
      . "$2"
      MUSH_DEBUG_FILE=$previous_debug_file
      ;;
    *)
  esac
}
EMBED
  else
    case "$1" in
      *)
        echo ": "
        ;;
    esac
  fi
}
release_2022() {
  if [ -z "$1" ]; then
    cat <<'EMBED'
use() { return 0; }
extern() { return 0; }
legacy() { return 0; }
module() { return 0; }
public() { return 0; }
embed() { return 0; }
inject() { return 0; }
EMBED
  else
    case "$1" in
      *)
        echo ": "
        ;;
    esac
  fi
}
test_2022() {
  if [ -z "$1" ]; then
    cat <<'EMBED'
mush_api_test_2022() {
  echo "Filter: $1"
  echo "Functions:"
  declare -F | awk '{print $3}' | grep "test_$1" | while read -r unit_test; do
    [ "${unit_test}" = "test_2022" ] && continue
    [ "${unit_test}" = "mush_api_test_2022" ] && continue
    echo "Testing: $unit_test"
    eval "$unit_test"
  done
}
EMBED
  else
    case "$1" in
      *)
        echo ": "
        ;;
    esac
  fi
}

public profile
public script

mush_build_print() {
    case "$1" in
        a)
            echo "a"
            ;;
        *)
            local print_options="
            a   a
            b   b
            c   c
            "
            console_error "unknown print request '$1'\n\nAvailable print options:\n${print_options}"
    esac
}

mush_build_profile_init() {
  local profile
  local target_dir

  is_release=$1
  target_dir=${MUSH_TARGET_DIR:-target}

  profile=debug
  if [ -n "${is_release}" ]; then
    profile=release
  fi

  MUSH_PROFILE="${profile}"
  MUSH_TARGET_DIR="${target_dir}"
  MUSH_TARGET_PATH="${target_dir}/${MUSH_PROFILE}"
}

mush_build_script_run() {
  local pwd

  pwd=$1
  build_script="${pwd}/build.sh"

  if [ -f "${build_script}" ]; then
    [ "$VERBOSE" -gt "3" ] && echo "Running build script"
    # shellcheck disable=SC1090
    source "${build_script}" || true
  fi
}

mush_space_iterable() {
    echo "$1" | tr '\n' ' ' | tr -s ' ' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
}

mush_color() {
    if [ -n "${MUSH_TERM_COLOR}" ]; then
        printf '%b' "$1"
    fi
}

public add
public build
public check
public fetch
public init
public install
public legacy
public metadata
public new
public run
public pkgid
public publish
public read_manifest
public search
public test
public uninstall
public info
public index

test0 () {
  echo "TEST"
}
parser_definition_build() {
  setup REST help:usage abbr:true -- "Compile the current package" ''

  msg   -- 'USAGE:' "  ${2##*/} build [OPTIONS]" ''

  msg   -- 'OPTIONS:'
  flag  VERBOSE        -v --verbose "counter:true" "init:=${VERBOSE}" -- "Use verbose output (-vv or -vvv to increase level)"

  flag  QUIET          -q --quiet       -- "Do not print mush log messages"
  flag  BUILD_RELEASE  -r --release     -- "Build artifacts in release mode, with optimizations"
  flag  NO_CACHE          --no-cache    -- "Disables the registry cache when build the package"

  param BUILD_TARGET   -t --target      -- "Build for the specific target"
  disp  :usage         -h --help        -- "Print help information"
}

run_build() {
  eval "$(getoptions parser_definition_build parse "$0")"
  parse "$@"
  eval "set -- $REST"

  exec_manifest_lookup "${PWD}"

  mush_feature_hook "build"

  [ "$VERBOSE" -gt "3" ] && echo "Profile init..."
  mush_build_profile_init "${BUILD_RELEASE}"

  [ "$VERBOSE" -gt "3" ] && echo "Profile init..."
  mush_build_script_run "${PWD}"

  [ "$VERBOSE" -gt "3" ] && echo "Legacy fetch..."
  exec_legacy_fetch "${MUSH_TARGET_PATH}"

  [ "$VERBOSE" -gt "3" ] && echo "Legacy build..."
  exec_legacy_build "${MUSH_TARGET_PATH}"

  [ "$VERBOSE" -gt "3" ] && echo "Dependencies..."
  update_strategy=lazy
  exec_dependencies "${MUSH_TARGET_PATH}" "${update_strategy}"

  local package_name="${MUSH_PACKAGE_NAME}"
  local package_version="${MUSH_PACKAGE_VERSION}"
  local pwd=${PWD}

  local src_file=src/main.sh
  local bin_file=${MUSH_TARGET_PATH}/${package_name}
  local out_file=${MUSH_TARGET_PATH}/lib.sh
  local lib_file=src/lib.sh

  console_status "Compiling" "${package_name} v${package_version} (${pwd})"

  if [ -n "${BUILD_RELEASE}" ]; then
    exec_build_release "${MUSH_TARGET_PATH}"
  else
    if [ "$BUILD_TARGET" = "release" ]; then
      exec_build_release "${MUSH_TARGET_PATH}"
    else
      if [ -f "${lib_file}" ]; then
        [ "$VERBOSE" -gt "3" ] && echo "Building lib: ${lib_file}"
        exec_build_lib_debug "${lib_file}" "${out_file}"
      else
        local lib_file=
      fi
      if [ -f "${src_file}" ]; then
        exec_build_bin_debug "src/main.sh" "${bin_file}" "${lib_file}"
      fi
    fi
  fi

  #printenv | grep MUSH_ > "${MUSH_TARGET_PATH}/.vars"

  console_status "Finished" "dev [unoptimized + debuginfo] target(s) in 0.00s"
}

parser_definition_check() {
	setup   REST help:usage abbr:true -- "Check a local package and all of its dependencies for errors" ''

  msg   -- 'USAGE:' "  ${2##*/} check [OPTIONS]" ''

	msg    -- 'OPTIONS:'
  flag   VERBOSE        -v --verbose counter:true init:=0 -- "Use verbose output (-vv or -vvv to increase level)"
  flag   QUIET          -q --quiet                        -- "Do not print mush log messages"
  flag   BUILD_RELEASE  -r --release                      -- "Check artifacts in release mode, with optimizations"

  param  BUILD_TARGET   -t --target                       -- "Check for the specific target"
	disp   :usage         -h --help                         -- "Print help information"
}

run_check() {
  eval "$(getoptions parser_definition_check parse "$0")"
  parse "$@"
  eval "set -- $REST"

  exec_manifest_lookup "${PWD}"

  local package_name="${MUSH_PACKAGE_NAME}"
  local package_version="${MUSH_PACKAGE_VERSION}"
  local pwd=${PWD}

  console_status "Checking" "${package_name} v${package_version} (${pwd})"

  console_status "Finished" "dev [unoptimized + debuginfo] target(s) in 0.00s"
}

parser_definition_fetch() {
  setup   REST help:usage abbr:true -- "Fetch dependencies of a package from the network" ''

  msg   -- 'USAGE:' "  ${2##*/} fetch [OPTIONS]" ''

  msg    -- 'OPTIONS:'
  flag   VERBOSE        -v --verbose counter:true init:=0 -- "Use verbose output (-vv or -vvv to increase level)"
  flag   QUIET          -q --quiet                        -- "Do not print mush log messages"

  param  BUILD_TARGET   -t --target                       -- "Check for the specific target"
  disp   :usage         -h --help                         -- "Print help information"
}

run_fetch() {
  eval "$(getoptions parser_definition_fetch parse "$0")"
  parse "$@"
  eval "set -- $REST"

  exec_manifest_lookup "${PWD}"

  local package_name="${MUSH_PACKAGE_NAME}"
  local package_version="${MUSH_PACKAGE_VERSION}"
  local pwd=${PWD}

  mush_registry_index_update

  exec_dependencies
}

parser_definition_init() {
	setup   REST help:usage abbr:true -- "Create a new mush package in an existing directory" ''

  msg   -- 'USAGE:' "  ${2##*/} init [OPTIONS] [path]" ''

	msg -- 'OPTIONS:'
  flag   VERBOSE        -v --verbose counter:true init:=0 -- "Use verbose output (-vv or -vvv to increase level)"
  flag   QUIET          -q --quiet                        -- "Do not print mush log messages"
	disp   :usage         -h --help                         -- "Print help information"
}

run_init() {
  eval "$(getoptions parser_definition_init parse "$0")"
  parse "$@"
  eval "set -- $REST"
  #echo "FLAG_C: $FLAG_C"
  #echo "MODULE_NAME: $MODULE_NAME"
  #echo "BUILD_TARGET: $BUILD_TARGET"

  if [ -e "Manifest.toml" ]; then
    console_error "'cargo init' cannot be run on existing Mush packages"
    exit 101
  fi

  exec_init
}

parser_definition_install() {
  setup  REST help:usage abbr:true -- "Install a Mush binary. Default location is \$HOME/.mush/bin" ''

  msg    -- 'USAGE:' "  ${2##*/} install [OPTIONS] [package]..." ''

  msg    -- 'OPTIONS:'
  flag   VERBOSE         -v --verbose counter:true "init:=${VERBOSE}" -- "Use verbose output (-vv or -vvv to increase level)"
  flag   QUIET           -q --quiet                        -- "Do not print mush log messages"

  param  PACKAGE_VERSION    --version                      -- "Specify a version to install"
  param  PACKAGE_PATH       --path                         -- "Filesystem path to local package to install"
  param  BUILD_TARGET    -t --target                       -- "Build for the specific target"
  flag   LIST            -l --list                         -- "List all installed packages and their versions"
  flag   SHOW_PLUGINS       --show-plugins                 -- "List all installed plugins"
  flag   FORCE           -f --force                        -- "Force overwriting existing crates or binaries"

  disp   :usage          -h --help                         -- "Print help information"
}

run_install() {
  eval "$(getoptions parser_definition_install parse "$0")"
  parse "$@"
  eval "set -- $REST"

  local temp_pwd
  local package_path
  local index_update

  mush_env

  [ "${VERBOSE}" -gt 2 ] && console_info "Installing" "with args '$@'"

  if [ -n "${LIST}" ]; then
    if [ -z "$(command -v tree 2>/dev/null || true)" ]; then
      temp_pwd=$PWD
      cd "$MUSH_HOME/registry/src" || exit 1
      find . -maxdepth 3 -type d | sed -e 's;[^/]*/;|__;g;s;__|;  |;g'
      cd "$temp_pwd" || exit 1
    else
      tree -d -L 3 "$MUSH_HOME/registry/src" | sed '$d'
    fi
  elif [ -n "${SHOW_PLUGINS}" ]; then
    if [ -z "$(command -v tree 2>/dev/null || true)" ]; then
      temp_pwd=$PWD
      cd "$MUSH_HOME/plugins" || exit 1
      find . -maxdepth 2 -type d | sed -e 's;[^/]*/;|__;g;s;__|;  |;g'
      cd "$temp_pwd" || exit 1
    else
      tree -d -L 2 "$MUSH_HOME/plugins" | sed '$d'
    fi
  elif [ -n "$PACKAGE_PATH" ]; then
    package_path=$(realpath "$PACKAGE_PATH")

    [ "${VERBOSE}" -gt 5 ] && console_info "Installing" "path='$PACKAGE_PATH' realpath='$package_path'"

    if [ -f "${package_path}/Manifest.toml" ]; then
      exec_manifest_lookup "${package_path}"
      if [ "${MUSH_PACKAGE_TYPE}" = "plugin" ]; then
        echo "Install plugin: $MUSH_PACKAGE_NAME"
      else
        MUSH_TARGET_PATH=target/release
        exec_legacy_fetch "${MUSH_TARGET_PATH}"
        exec_legacy_build "${MUSH_TARGET_PATH}"
        exec_dependencies "${MUSH_TARGET_PATH}"
        exec_build_release "$@"
        exec_install_binaries
        exec_install
      fi
    else
      console_error "'${package_path}' does not contain a Manifest.toml file. --path must point to a directory containing a Manifest.toml file."
    fi
  else
    if [ "$#" -eq 0 ]; then
      if [ -f "Manifest.toml" ]; then
        console_error "Using 'mush install' to install the binaries for the package in current working directory is not supported, use 'mush install --path .' instead. Use 'mush build' if you want to simply build the package."
      else
        console_error "'${PWD}' is not a package root; specify a package to install, or use --path or --git to specify an alternate source."
      fi
    else
      [ -n "${FORCE}" ] && index_update=full
      mush_registry_index_update "${index_update}"
      exec_install_from_index "$1" "${PACKAGE_VERSION}"
    fi
  fi
}

parser_definition_legacy() {
  setup   REST help:usage abbr:true -- \
    "Usage: ${2##*/} legacy [options...] [arguments...]"
  msg -- '' 'Add legacy dependencies to a Manifest.toml file' ''
  msg -- 'Options:'
  flag    FLAG_C       -c --flag-c
  param   MODULE_NAME  -n --name
  disp    :usage       -h --help
}

run_legacy() {
  eval "$(getoptions parser_definition_legacy parse "$0")"
  parse "$@"
  eval "set -- $REST"
  #echo "FLAG_C: $FLAG_C"
  #echo "MODULE_NAME: $MODULE_NAME"

  exec_manifest_lookup "${PWD}"

  echo "GLOBAL: $GLOBAL"
  echo "MANIFEST: $MUSH_MANIFEST_DIR"

  i=0
  while [ $# -gt 0 ] && i=$((i + 1)); do
    module_url=$1
    module_name=$(basename "$1")
    module_file=target/debug/legacy/$module_name
    echo "$i Downloading '$module_name' from $1"
    curl -sL "${module_url}" -o "${module_file}"
    chmod +x "${module_file}"

    if grep -q "\[legacy\]" "$MUSH_MANIFEST_DIR/Manifest.toml"; then
        legacy_line=$(grep -n -m 1 "\[legacy\]" "$MUSH_MANIFEST_DIR/Manifest.toml" | cut -d: -f1)
        legacy_tail=$((legacy_line + 1))
        echo "The section '[legacy]' exists in the INI file at ${legacy_line}."
        head -n "${legacy_line}" "$MUSH_MANIFEST_DIR/Manifest.toml" > "$MUSH_MANIFEST_DIR/Manifest.toml.tmp"
        echo "${module_name} = \"${module_url}\"" >> "$MUSH_MANIFEST_DIR/Manifest.toml.tmp"
        tail -n +"${legacy_line}" "$MUSH_MANIFEST_DIR/Manifest.toml.tmp"
        mv "$MUSH_MANIFEST_DIR/Manifest.toml.tmp" "$MUSH_MANIFEST_DIR/Manifest.toml"
    else
      echo "[legacy]" >> "$MUSH_MANIFEST_DIR/Manifest.toml"
      echo "${module_name} = \"${module_url}\"" >> "$MUSH_MANIFEST_DIR/Manifest.toml"
    fi

    echo "OK!"
    shift
  done

  #curl -sL https://github.com/ko1nksm/getoptions/releases/download/v3.3.0/getoptions -o target/debug/legacy/getoptions
  #curl -sL https://github.com/ko1nksm/getoptions/releases/download/v3.3.0/gengetoptions -o target/debug/legacy/gengetoptions
}

parser_definition_metadata() {
	setup REST help:usage abbr:true -- "Output the resolved dependencies of a package, the concrete used versions including overrides" ''

  msg   -- 'USAGE:' "  ${2##*/} metadata [OPTIONS] [path]" ''

	msg   -- 'OPTIONS:'
  flag  VERBOSE        -v --verbose counter:true init:=0 -- "Use verbose output (-vv or -vvv to increase level)"
  flag  QUIET          -q --quiet                        -- "Do not print mush log messages"
	disp  :usage         -h --help                         -- "Print help information"
}

run_metadata() {
  local plugins

  eval "$(getoptions parser_definition_metadata parse "$0")"
  parse "$@"
  eval "set -- $REST"

  mush_env

  exec_manifest_lookup "${PWD}"

  echo "Package: ${MUSH_PACKAGE_NAME}"
  echo "Version: ${MUSH_PACKAGE_VERSION}"
  echo "Type:    ${MUSH_PACKAGE_TYPE}"

  echo ""
  echo "Features:"
  echo "${MUSH_FEATURES}" | sed 's/^/ - /' | sed 's/=/: /1'

  plugins=$(exec_plugin_list)

  if [ -n "${plugins}" ]; then
    echo ""
    echo "Plugins:"
    echo "${plugins}" | sed 's/^/ - /' | sed 's/=/: /1'
  fi
}

parser_definition_new() {
	setup   REST help:usage abbr:true -- "Compile the current package" ''

  msg   -- 'USAGE:' "  ${2##*/} build [OPTIONS] [SUBCOMMAND]" ''

	msg -- 'OPTIONS:'
	flag    FLAG_C       -c --flag-c
	param   MODULE_NAME  -n --name
	param   BUILD_TARGET -t --target
	disp    :usage       -h --help
}

run_new() {
  eval "$(getoptions parser_definition_new parse "$0")"
  parse "$@"
  eval "set -- $REST"
  #echo "FLAG_C: $FLAG_C"
  #echo "MODULE_NAME: $MODULE_NAME"
  #echo "BUILD_TARGET: $BUILD_TARGET"

  if [ -e "$1" ]; then
    console_error "Destination '$1' already exists"
    exit 101
  fi

  mkdir -p "$1"

  cd "$1" || exit 101

  exec_init
}

parser_definition_run() {
  setup   REST error:run_args_error help:usage abbr:true -- "Run a binary or example of the local package" ''

  msg   -- 'USAGE:' "  ${2##*/} run [OPTIONS] [--] [args]..." ''

  msg -- 'OPTIONS:'
  flag   QUIET          -q --quiet                        -- "Do not print mush log messages"
  param  EXAMPLE_NAME      --example                      -- "Name of the example target to run"
  flag   VERBOSE        -v --verbose counter:true init:=0 -- "Use verbose output (-vv or -vvv to increase level)"

  disp   :usage         -h --help                         -- "Print help information"
}

run_args_error() {
  case "$2" in
    unknown)
      echo -e "\e[1m\e[31merror:\e[0m unexpected argument '\e[33m-${3}\e[0m' found"
      echo -e ""
      echo -e "\e[32m  tip:\e[0m to pass '\e[33m${3}\e[0m' as a value, use '\e[32m-- ${3}\e[0m'"
      echo -e ""
      echo -e "\e[1m\e[4mUsage:\e[0m \e[1mmush run\e[0m [OPTIONS] [args]..."
      echo -e ""
      echo -e "For more information, try '\e[1m--help\e[0m'."
      ;;
    *)
      echo "ERROR: ($2,$3) $1"
      ;;
  esac
  exit 101
}

run_run() {
  eval "$(getoptions parser_definition_run parse "$0")"
  parse "$@"
  eval "set -- $REST"
  #echo "FLAG_C: $FLAG_C"
  #echo "MODULE_NAME: $MODULE_NAME"
  #echo "BUILD_TARGET: $BUILD_TARGET"

  exec_manifest_lookup "${PWD}"

  MUSH_TARGET_PATH=target/debug

  exec_legacy_fetch "${MUSH_TARGET_PATH}"
  exec_legacy_build "${MUSH_TARGET_PATH}"

  if [ -z "${EXAMPLE_NAME}" ]; then
    local src_file=src/main.sh
    local bin_file=target/debug/$MUSH_PACKAGE_NAME
  else
    local src_file=examples/$EXAMPLE_NAME.sh
    local bin_file=target/debug/examples/$EXAMPLE_NAME

    if [ ! -f "${src_file}" ]; then
      console_error "no example target named '${EXAMPLE_NAME}'."
      echo ""
      local examples=$(find examples/ -type f -name '*.sh' -exec basename {} .sh \; 2>/dev/null | sed 's/^/    /')
      [ -n "${examples}" ] && echo -e "Available example targets:\n${examples}\n"
      exit 101
    fi
  fi

  console_status "Compiling" "'${bin_file}'"

  local lib_file=src/lib.sh
  if [ -f "${lib_file}" ]; then
    compile_file "${lib_file}"
  else
    local lib_file=
  fi

  exec_build_bin_debug "${src_file}" "${bin_file}" "${lib_file}"

  compile_file "${src_file}"

  console_status "Running" "'${bin_file}'"

  exec "${bin_file}" "$@"
}

parser_definition_pkgid() {
	setup   REST help:usage abbr:true -- "Create a new mush package in an existing directory" ''

  msg   -- 'USAGE:' "  ${2##*/} pkgid [OPTIONS] [path]" ''

	msg -- 'OPTIONS:'
  flag   VERBOSE        -v --verbose counter:true init:=0 -- "Use verbose output (-vv or -vvv to increase level)"
  flag   QUIET          -q --quiet                        -- "Do not print mush log messages"
	disp   :usage         -h --help                         -- "Print help information"
}

run_pkgid() {
  eval "$(getoptions parser_definition_init parse "$0")"
  parse "$@"
  eval "set -- $REST"
  #echo "FLAG_C: $FLAG_C"
  #echo "MODULE_NAME: $MODULE_NAME"
  #echo "BUILD_TARGET: $BUILD_TARGET"


}

parser_definition_publish() {
	setup   REST help:usage abbr:true -- "Package and upload this package to the registry" ''

  msg     -- 'USAGE:' "  ${2##*/} publish [OPTIONS]" ''

	msg     -- 'OPTIONS:'
	flag    FLAG_C       -c --flag-c
	flag    ALLOW_DIRTY  --allow-dirty  -- "Build artifacts in release mode, with optimizations"
	param   MODULE_NAME  -n --name

	param   BUILD_TARGET -t --target
	disp    :usage       -h --help
}

run_publish() {
  eval "$(getoptions parser_definition_publish parse "$0")"
  parse "$@"
  eval "set -- $REST"
  #echo "FLAG_C: $FLAG_C"
  #echo "MODULE_NAME: $MODULE_NAME"
  echo "ALLOW_DIRTY: $ALLOW_DIRTY"

  MUSH_TARGET_PATH=target/release
  exec_manifest_lookup "${PWD}"

  exec_legacy_fetch "${MUSH_TARGET_PATH}"
  exec_legacy_build "${MUSH_TARGET_PATH}"

  exec_build_release "$@"

  exec_publish
}

parser_definition_read_manifest() {
	setup   REST help:usage abbr:true -- "Create a new mush package in an existing directory" ''

  msg   -- 'USAGE:' "  ${2##*/} init [OPTIONS] [path]" ''

	msg -- 'OPTIONS:'
  flag   VERBOSE        -v --verbose counter:true init:=0 -- "Use verbose output (-vv or -vvv to increase level)"
  flag   QUIET          -q --quiet                        -- "Do not print mush log messages"
	disp   :usage         -h --help                         -- "Print help information"
}

run_read_manifest() {
  eval "$(getoptions parser_definition_init parse "$0")"
  parse "$@"
  eval "set -- $REST"
  #echo "FLAG_C: $FLAG_C"
  #echo "MODULE_NAME: $MODULE_NAME"
  #echo "BUILD_TARGET: $BUILD_TARGET"

  exec_manifest_lookup
}

parser_definition_search() {
  setup   REST help:usage abbr:true -- "Search registry for package" ''

  msg   -- 'USAGE:' "  ${2##*/} search [OPTIONS] [query]..." ''

  msg    -- 'OPTIONS:'
  flag   VERBOSE        -v --verbose counter:true "init:=${VERBOSE}" -- "Use verbose output (-vv or -vvv to increase level)"
  flag   QUIET          -q --quiet                        -- "Do not print mush log messages"
  flag   FORCE_REFRESH     --force-refresh                -- "Force refresh of the registry index"

  disp   :usage         -h --help                         -- "Print help information"
}

run_search() {
  eval "$(getoptions parser_definition_search parse "$0")"
  parse "$@"
  eval "set -- $REST"

  local query
  local index_update
  local cyan
  local reset

  mush_env

  query="$1"

  index_update=lazy
  [ -n "${FORCE_REFRESH}" ] && index_update=full
  mush_registry_index_update "${index_update}"

  #echo "Query: ${query}"

  awk '{name=$1; desc=""; if (index($0, "#")) desc=substr($0, index($0, "#")); printf "%-12s %s\n", name, desc}' \
      "${MUSH_REGISTRY_INDEX}" \
      | grep --color=auto -i "${query}" \
      | head -n 20

  cyan=$(mush_color '\033[36m')
  reset=$(mush_color '\033[0m')
  echo "${cyan}note${reset}: to learn more about a package, run '${cyan}mush info <name>${reset}'" >&2
}

parser_definition_test() {
	setup   REST help:usage abbr:true -- "Execute all unit and integration tests and build examples of a local package" ''

  msg   -- 'USAGE:' "  ${2##*/} test [OPTIONS] [TESTNAME] [-- [args]...]" ''

  # Arguments:
  #   [TESTNAME]  If specified, only run tests containing this string in their names
  #   [args]...   Arguments for the test binary

	msg    -- 'OPTIONS:'
  flag   VERBOSE        -v --verbose counter:true init:=0 -- "Use verbose output (-vv or -vvv to increase level)"
  flag   QUIET          -q --quiet                        -- "Do not print mush log messages"
  flag   BUILD_RELEASE  -r --release                      -- "Build artifacts in release mode, with optimizations"

  param  BUILD_TARGET   -t --target                       -- "Build for the specific target"
	disp   :usage         -h --help                         -- "Print help information"
}

run_test() {
  eval "$(getoptions parser_definition_test parse "$0")"
  parse "$@"
  eval "set -- $REST"

  exec_manifest_lookup "${PWD}"

  mush_build_profile_init

  exec_legacy_fetch "${MUSH_TARGET_PATH}"
  exec_legacy_build "${MUSH_TARGET_PATH}"

  exec_dependencies "${MUSH_TARGET_PATH}"

  local package_name="${MUSH_PACKAGE_NAME}"
  local package_version="${MUSH_PACKAGE_VERSION}"
  local pwd=${PWD}

  console_status "Compiling" "${package_name} v${package_version} (${pwd})"

  exec_build_test

  bin_file=target/debug/bin/test/$MUSH_PACKAGE_NAME

  console_status "Compiling" "'${bin_file}'"

  exec "$bin_file" "$@"
}

parser_definition_uninstall() {
	setup   REST help:usage abbr:true -- "Compile the current package" ''

  msg   -- 'USAGE:' "  ${2##*/} build [OPTIONS] [SUBCOMMAND]" ''

	msg -- 'OPTIONS:'
	flag    FLAG_C       -c --flag-c
	param   MODULE_NAME  -n --name
	param   BUILD_TARGET -t --target
	disp    :usage       -h --help
}

run_uninstall() {
  eval "$(getoptions parser_definition_install parse "$0")"
  parse "$@"
  eval "set -- $REST"
  #echo "FLAG_C: $FLAG_C"
  #echo "MODULE_NAME: $MODULE_NAME"
  #echo "BUILD_TARGET: $BUILD_TARGET"


  cosnole_status "Removing" "/home/francesco/.cargo/bin/cask"
}

parser_definition_info() {
	setup REST help:usage abbr:true -- "Display information about a package in the registry" ''

  msg   -- 'USAGE:' "  ${2##*/} info [OPTIONS] [PACKAGE]" ''

	msg   -- 'OPTIONS:'
  flag  VERBOSE        -v --verbose counter:true init:=0 -- "Use verbose output (-vv or -vvv to increase level)"
  flag  QUIET          -q --quiet                        -- "Do not print mush log messages"
	disp  :usage         -h --help                         -- "Print help information"
}

run_info() {
  local package_name
  local package_entry
  local bold
  local green
  local reset

  eval "$(getoptions parser_definition_info parse "$0")"
  parse "$@"
  eval "set -- $REST"

  package_name="$1"

  if [ -z "${package_name}" ]; then
    console_error "the following required arguments were not provided: PACKAGE"
    exit 1
  fi

  mush_env
  mush_registry_index_update

  while IFS= read -r line; do
    [ -z "$line" ] && continue
    case "$line" in \#*) continue ;; esac

    case "$line" in
      "$package_name "*)
        [ "${VERBOSE}" -gt 2 ] && echo "Found: $line"
        package_entry="${line%%#*}"
        package_description="$(printf '%s\n' "${line}" | sed -n 's/^[^#]*# *\([^ ]\(.*\)\)/\1/p')"
        break
        ;;
    esac
  done < "$MUSH_REGISTRY_INDEX"

  if [ -n "$package_entry" ]; then
    # shellcheck disable=SC2086
    set -- $package_entry
    package_name=$1
    package_url=$2
    package_path=$3

    bold=$(mush_color '\033[1m')
    green=$(mush_color '\033[32m')
    cyan=$(mush_color '\033[36m')
    yellow=$(mush_color '\033[33m')
    reset=$(mush_color '\033[0m')

    echo "${bold}Name:${reset} ${green}${package_name}${reset}"
    [ -n "$package_description" ] && echo "${bold}Desc:${reset} ${cyan}${package_description}${reset}"
    echo "${bold}Repo:${reset} ${cyan}${package_url}${reset}"
    [ -n "$package_path" ] && echo "${bold}Path:${reset} ${cyan}${package_path}${reset}"

    echo ""
    echo "${bold}Versions:${reset}"

    echo -n "${yellow}"
    mush_registry_package_versions "$package_url" | sed 's/^/ - /'
    echo -n "${reset}"

    #echo "Entry: $package_entry"
  else
    console_error "could not find '$package_name' in registry '${MUSH_REGISTRY_URL}'" >&2
    exit 101
  fi
}

parser_definition_index() {
	setup REST help:usage abbr:true -- "Show or manage the index status of current registry" ''

  msg   -- 'USAGE:' "  ${2##*/} index [OPTIONS]" ''

	msg   -- 'OPTIONS:'
  flag  VERBOSE        -v --verbose counter:true init:=0 -- "Use verbose output (-vv or -vvv to increase level)"
  flag  QUIET          -q --quiet                        -- "Do not print mush log messages"
	disp  :usage         -h --help                         -- "Print help information"
}

run_index() {
  eval "$(getoptions parser_definition_index parse "$0")"
  parse "$@"
  eval "set -- $REST"

  mush_registry_index_update

  cat "$MUSH_REGISTRY_INDEX"
}

extern package code_dumper

mush_errors_explain() {
    echo "Explain: $1"
}

error_package_not_found() {
  local package_name=$MUSH_PACKAGE_NAME
  local extern_package_name=$1
  local debug_file=$2
  local debug_line

  debug_line=$(awk "/extern package ${extern_package_name}/{ print NR; exit }" "${debug_file}")
  [ -z "${debug_line}" ] && debug_line=$(awk "/${extern_package_name}/{ print NR; exit }" "${debug_file}")
  [ -z "${debug_line}" ] && debug_line=1

  console_error_code "E0463" "can't find package for '${extern_package_name}'"
  code_dumper "${debug_file}" "${debug_line}" "${extern_package_name}" "can't find package"

  console_hint "For more information about this error, try 'mush --explain E0463'."
  console_error "could not compile '${package_name}' due to previous error"
}

error_E0583_file_not_found() {
  local package_name
  local module_name
  local debug_file
  local debug_line
  local help

  package_name=$MUSH_PACKAGE_NAME
  module_name=$1
  debug_file=$2
  debug_line=$3
  help="module not found" "to create the module '${module_name}', create file 'src/mod2.rs' or 'src/mod2/mod.rs'"

  console_error_code "E0583" "file not found for module '${module_name}'"
  code_dumper "${debug_file}" "${debug_line}" "${module_name}" "${help}"

  console_hint "For more information about this error, try 'mush --explain E0463'."
  console_error "could not compile '${package_name}' due to previous error"
}

console_error_code() {
   echo -e "${ESCAPE}[1;31merror[$1]${ESCAPE}[1;39m: $2${ESCAPE}[0m" >&2
}

console_hint() {
  echo -e "${ESCAPE}[1;39m$1${ESCAPE}[0m" >&2
}
#!/usr/bin/env bash
## BP010: Release metadata
## @build_type: lib
## @build_date: 2025-05-17T21:54:25Z
set -e
use() { return 0; }
extern() { return 0; }
legacy() { return 0; }
module() { return 0; }
public() { return 0; }
embed() { return 0; }
inject() { return 0; }
## BP004: Compile the entrypoint
code_dumper() {
  local file
  local line
  local keyword
  local column
  local source
  local padding
  local keyword_padding
  local message
  local help
  file=$1
  line=$2
  keyword=$3
  message=$4
  help=$5
  source=$(sed -n "${line}p" "${file}")
  column=${source%%$keyword*}
  padding=$(echo "$line" | sed 's/[0-9]/ /g')
  keyword_padding=$(echo "$column" | sed 's/./ /g')
  keyword_size=$(echo "$keyword" | sed 's/./^/g')
  echo -e "\e[0m${padding}\e[0m\e[0m\e[1m\e[38;5;12m--> \e[0m\e[0m${file}:${line}:${#column}\e[0m"
  echo -e "\e[0m${padding} \e[0m\e[0m\e[1m\e[38;5;12m|\e[0m"
  echo -e "\e[0m\e[1m\e[38;5;12m${line}\e[0m\e[0m \e[0m\e[0m\e[1m\e[38;5;12m|\e[0m\e[0m \e[0m\e[0m${source}\e[0m"
  echo -e "\e[0m${padding} \e[0m\e[0m\e[1m\e[38;5;12m| ${keyword_padding}\e[0m\e[0m\e[1m\e[38;5;9m${keyword_size}\e[0m\e[0m \e[0m\e[0m\e[1m\e[38;5;9m${message}\e[0m"
  if [ -n "${help}" ]; then
    echo -e "\e[0m${padding} \e[0m\e[0m\e[1m\e[38;5;12m|\e[0m"
    echo -e "\e[0m${padding} \e[0m\e[0m\e[1m\e[38;5;12m= \e[0m\e[1;39mhelp:\e[0m ${help}\e[0m"
  fi
  echo ""
}

mush_feature_hook() {
  local feature
  local feature_hook
  local feature_name
  local feature_value
  local feature_function
  local plugin
  local plugin_name
  local plugin_file
  local plugins

  feature_hook=$1

  [ "${VERBOSE}" -gt 7 ] && echo "Loaded features: ${MUSH_FEATURES} args: $@"

  echo "${MUSH_FEATURES}" | while IFS=$'\n' read -r feature && [ -n "$feature" ]; do
    feature_name=${feature%=*}
    feature_value=${feature#*=}

    [ -z "${plugins}" ] && plugins=$(exec_plugin_list "${MUSH_TARGET_PATH}")

    if [ -n "${plugins}" ]; then
      echo "${plugins}" | while IFS=$'\n' read -r plugin && [ -n "$plugin" ]; do

        plugin_name=${plugin%%=*}
        plugin_file=${plugin#*=}

        local feature_function="__plugin_${plugin_name}__feature_${feature_name}__hook_${feature_hook}__"

        [ "${VERBOSE}" -gt 7 ] && echo "Looking for feature function '${feature_function}' with value '${feature_value}'"

        if [ -n "$feature_value" ]; then
          [ -f "${plugin_file}" ] && source "${plugin_file}"
          if [ "$(type -t "$feature_function" && true)" = "function" ]; then
            $feature_function "${feature_value}" "${@:2}"
          fi
        fi
      done
    fi
  done

  #echo "Warning: Feature '${feature_name}' has no '${feature_hook}' hook defined. Expected '${feature_function}'"
}

public apt
public basher
public bpkg
public git
public mush
public pip
public path

bpkg_dependency() {
  local pwd
  local package_name
  local package_full_name
  local package_version_constraint
  local dependency_type
  local package_cache_file
  local package_cache_hash

  pwd=$PWD
  package_name=$1
  package_full_name=$2
  package_version_constraint=$3
  dependency_type=$4

  package_cache_file="./deps/.mush_cache/${package_name}"
  package_cache_hash="${package_full_name}"

  [ "${VERBOSE}" -gt 4 ] && echo "Processing 'bpkg' dependency '$package_name', '$package_full_name', 'source=bpkg'"

  if [ -f "$package_cache_file" ] && [ "$(cat "$package_cache_file")" = "$package_cache_hash" ]; then
    echo "Package already exists, skipping..."
  else
    if [ -z "$(command -v bpkg || true)" ]; then
      console_error "failed to run 'bpkg' to fetch dependency '$package_full_name' from remote registry\n\nYou can install it by running:\n  curl -Lo- https://raw.githubusercontent.com/bpkg/bpkg/master/setup.sh | bash"
      exit 101
    fi

    bpkg install "${package_full_name}"

    #mkdir -p bin || true
    #[ -d "./deps/bin" ] && cp -r ./deps/bin/* ./bin/

    if [ -d "./deps" ]; then
      mkdir -p "./deps/.mush_cache" || true
      echo "$package_cache_hash" > "$package_cache_file"
    fi
  fi
}

git_dependency() {
  local pwd=$PWD
  local package_dir=$1
  local package_url=$2
  local package_tag=$3

  cd "${MUSH_DEPS_DIR}" || exit 101

  git clone --depth 1 --branch "$3" "$2" "${package_dir}" > /dev/null 2>&1

  cd "${pwd}" || exit 101
}

mush_dependency() {
  local package_name
  local package_full_name
  local package_version_constraint
  local dependency_type
  local update_strategy

  package_name=$1
  package_full_name=$2
  package_version_constraint=$3
  dependency_type=$4
  update_strategy=${5:-lazy}

  mush_registry_index_update "${update_strategy}"

  [ "${VERBOSE}" -gt 4 ] && echo "Processing dependency '$1', '$2', 'source=${package_source}'"

  exec_install_from_index "${package_full_name}" "${package_version_constraint}" "${dependency_type}"
}

mush_path_dependency() {
  local pwd
  local package_name
  local package_full_name
  local package_version_constraint
  local dependency_type
  local package_cache_file
  local package_cache_hash

  pwd=$PWD
  package_name=$1
  package_full_name=$2
  package_version_constraint=$3
  dependency_type=$4

  echo "Path: $package_name"
}

public github
public index

github_get_repository() {
  local repository_url

  repository_url=$(git config --get remote.origin.url)

  case "${repository_url}" in
    http*)
      echo "${repository_url}" | sed 's#.*github\.com/##g' | sed 's/\.git$//g'
      ;;
    git*)
      echo "${repository_url}" | cut -d: -f2 | sed 's/\.git$//g'
      ;;
  esac
}

github_create_release() {
  local repository
  local release_tag

  repository="${MUSH_GITHUB_REPOSITORY}"
  release_tag="$1"

  curl \
     -s -X POST \
     -H "Accept: application/vnd.github+json" \
     -H "Authorization: Bearer ${GITHUB_TOKEN}" \
     https://api.github.com/repos/${repository}/releases \
     -d "{\"tag_name\":\"${release_tag}\",\"target_commitish\":\"main\",\"name\":\"${release_tag}\",\"body\":\"Description of the release\",\"draft\":false,\"prerelease\":false,\"generate_release_notes\":false}" \
     | grep '"id"' | head -1 | sed 's/[^0-9]*//g'
}

github_upload_release_asset() {
  local repository
  local release_id
  local asset_file
  local asset_name
  local upload_url
  local upload_result

  repository="${MUSH_GITHUB_REPOSITORY}"
  release_id="$1"
  asset_file="$2"
  asset_name=$(basename "$asset_file")
  upload_url=https://uploads.github.com/repos/${repository}/releases/$release_id/assets?name=${asset_name}

  upload_result=$(curl -s -X POST "${upload_url}" \
    -H "Authorization: Bearer ${GITHUB_TOKEN}" \
    -H "Content-Type: application/octet-stream" \
    --data-binary @"$asset_file")

  echo "${upload_result}" >&2

  echo "${upload_result}" | sed 's/.*"browser_download_url"//g' | cut -d'"' -f2
}

github_delete_release_asset() {
  local repository
  local asset_id

  repository="${MUSH_GITHUB_REPOSITORY}"
  asset_id="$1"

  curl \
    -s -X DELETE \
    -H "Accept: application/vnd.github+json" \
    -H "Authorization: Bearer ${GITHUB_TOKEN}" \
    https://api.github.com/repos/${repository}/releases/assets/${asset_id}
}

github_get_release_asset_id() {
  local repository
  local release_id
  local asset_name

  repository="${MUSH_GITHUB_REPOSITORY}"
  release_id="$1"
  asset_name="$(basename "$2")"

  curl \
    -s -X GET \
    -H "Accept: application/vnd.github+json" \
    -H "Authorization: Bearer ${GITHUB_TOKEN}" \
    https://api.github.com/repos/${repository}/releases/${release_id}/assets \
    | grep '^    "id"\|"name"' | paste - - | grep "\"${asset_name}\"" | cut -d, -f1 | cut -d: -f2 | xargs
}

github_get_release_id() {
  local repository
  local release_tag

  repository="${MUSH_GITHUB_REPOSITORY}"
  release_tag="$1"

  curl \
    -s -X GET \
    -H "Accept: application/vnd.github+json" \
    -H "Authorization: Bearer ${GITHUB_TOKEN}" \
    "https://api.github.com/repos/${repository}/releases/tags/${release_tag}" \
    | grep '"id"' | head -1 | sed 's/[^0-9]*//g'
}

mush_registry_index_update()
{
  MUSH_HOME="${MUSH_HOME:-$HOME/.mush}"
  MUSH_REGISTRY_URL=https://github.com/javanile/mush
  MUSH_REGISTRY_ID=$(echo "${MUSH_REGISTRY_URL}" | tr -s '/:.' '-')
  MUSH_REGISTRY_INDEX="${MUSH_HOME}/registry/index/${MUSH_REGISTRY_ID}.index"
  MUSH_REGISTRY_CACHE="${MUSH_HOME}/registry/index/${MUSH_REGISTRY_ID}.cache"
  MUSH_REGISTRY_SRC="${MUSH_HOME}/registry/src/${MUSH_REGISTRY_ID}"

  local packages_file_url
  local packages_cache_hash
  local packages_hash

  local update_strategy="${1:-lazy}"

  [ "$VERBOSE" -gt "0" ] && console_status "Indexing" "updating strategy: $update_strategy"

  if [ -f "${MUSH_REGISTRY_CACHE}" ]; then
    while read -r line; do
      [ "$VERBOSE" -gt "2" ] && echo "Entry cache: ${line}"
      [ -z "${line}" ] && continue
      [ "$(echo "$line" | cut -c1)" = "#" ] && continue
      packages_file_url="$(echo "${line}" | awk '{print $1}')"
      packages_cache_hash="$(echo "${line}" | awk '{print $2}')"
      packages_hash="$(curl -I -s -L -H "Pragma: no-cache" -H "Cache-Control: no-cache" "${packages_file_url}" | grep -i ETag | awk '{print $2}' | tr -d '"')"
      if [ "${packages_cache_hash}" = "${packages_hash}" ]; then
        [ "$VERBOSE" -gt "3" ] && echo "Entry cache: ${line} [unchanged]"
      else
        rm -fr "${MUSH_HOME}/registry/index" && true
      fi
    done < "${MUSH_REGISTRY_CACHE}"
  fi

  if [ "${update_strategy}" = "full" ]; then
    rm -fr "${MUSH_HOME}/registry/index" && true
  fi

  if [ ! -f "${MUSH_REGISTRY_INDEX}" ]; then
    console_status "Updating" "mush packages index"
    mkdir -p "${MUSH_HOME}/registry/index"
    > "${MUSH_REGISTRY_INDEX}"
    local packages_file_url="${MUSH_REGISTRY_URL}/raw/main/.packages"
    local packages_hash="$(curl -I -s -L "${packages_file_url}" | grep -i ETag | awk '{print $2}' | tr -d '"')"
    echo "${packages_file_url} ${packages_hash}" > "${MUSH_REGISTRY_CACHE}"
    mush_registry_index_parse "${packages_file_url}"
  elif [ "${VERBOSE}" -gt "0" ]; then
    console_status "Updating" "index through cache"
  fi
}

mush_registry_index_parse() {
  local packages_file
  local packages_local_file
  local packages_index
  local entry
  local entry_type
  local entry_description
  local package_name
  local package_url
  local package_path
  local package_version
  local packages_file_url
  local packages_hash
  local packages_index

  packages_file=$1
  packages_local_file="${MUSH_HOME}/registry/index/$(echo "${packages_file}" | tr -s '/:.' '-')"
  packages_index="${MUSH_HOME}/registry/index/$(echo "${packages_file}" | tr -s '/:.' '-')"

  curl -s -L -H 'Cache-Control: no-cache, no-store' "${packages_file}" > "${packages_local_file}"

  #sort -t "|" -k 1,1 -o "${packages_local_file}" "${packages_local_file}"

  if [ ! -s "${packages_local_file}" ]; then
    console_error "spurious network error: Couldn't retrieve '.packages' file at '${packages_file}'"
  fi

  while read -r line; do
    #echo "Entry: ${line}"
    [ -z "${line}" ] && continue
    [ "$(echo "$line" | cut -c1)" = "#" ] && continue

    entry=$(echo "${line}" | cut -d'#' -f1)
    entry_type=$(echo "${line}" | awk '{print $1}')
    entry_description=$(case "$line" in *#*) echo "$line" | cut -d'#' -f2 | sed 's/^[[:space:]]*//; s/[[:space:]]*$//' ;; *) echo "(no description)" ;; esac)

    case "${entry_type}" in
      "index")
        entry_url=$(echo "${entry}" | awk '{print $2}')
        packages_file_url="${entry_url}/raw/main/.packages"
        packages_hash="$(curl -I -s -L "${packages_file_url}" | grep -i ETag | awk '{print $2}' | tr -d '"')"
        mush_registry_index_parse "${packages_file_url}"
        echo "${packages_file_url} ${packages_hash}" >> "${MUSH_REGISTRY_CACHE}"
        ;;
      "package")
        package_name=$(echo "${entry}" | awk '{print $2}')
        package_url=$(echo "${entry}" | awk '{print $3}')
        package_path=$(echo "${entry}" | awk '{print $4}')
        package_version=$(echo "${entry}" | awk '{print $5}')
        echo "${package_name} ${package_url} ${package_path} ${package_version} # ${entry_description}" >> "${MUSH_REGISTRY_INDEX}"
        ;;
      *)
        console_error "not supported entry type at '${packages_file}'"
        ;;
    esac
  done < "${packages_local_file}"
}

mush_registry_package_versions() {
  local package_url

  package_url=$1

  git ls-remote --heads "$package_url" | sed 's?.*refs/heads/??' | grep -E '^[a-z]+$'

  # git ls-remote --tags "$package_url" | sed -n 's|.*refs/tags/\(v\?\([0-9]\+\.[0-9]\+\.[0-9]\+\)\)$|\1|p'
  git ls-remote --tags "$package_url"  | \
                                        grep -o 'refs/tags/v\?[0-9]*\.[0-9]*\.[0-9]*$' | \
                                        sed 's|refs/tags/||' | \
                                        sort -V -r


  }
public build_debug
public build_release
public build_test
public init
public install
public legacy_fetch
public legacy_build
public manifest_lookup
public compile
public publish
public plugin
public dependencies
# @score: 1

exec_build_bin_debug() {
  local src_file
  local bin_file
  local lib_file

  src_file=$1
  bin_file=$2
  lib_file=$3

  mkdir -p "$(dirname "${bin_file}")"

  #echo "BUILD_DEBUG: ${src_file} -> ${bin_file}"

  local name=$MUSH_PACKAGE_NAME

  local build_file="${bin_file}.tmp"
  local final_file="${bin_file}"

  compile_file "${src_file}"

  echo "#!/usr/bin/env bash" > "${build_file}"
  echo "set -e" >> "${build_file}"
  echo "" >> "${build_file}"

  MUSH_TARGET_FILE="${bin_file}"
  MUSH_TARGET_PATH="$(dirname "${bin_file}")"
  MUSH_DEBUG_TARGET_FILE="${PWD}/${bin_file}"
  MUSH_DEBUG_PATH="${PWD}"

  {
    echo "# @build_section: BS002 - Package and debug variables"
    echo "MUSH_PACKAGE_NAME=\"${MUSH_PACKAGE_NAME}\""
    echo "MUSH_TARGET_FILE=\"${MUSH_TARGET_FILE}\""
    echo "MUSH_TARGET_PATH=\"${MUSH_TARGET_PATH}\""
    echo "MUSH_DEBUG_TARGET_FILE=\"\$(realpath \"\$0\")\""
    echo "MUSH_DEBUG_PATH=\"\$(realpath \"\$(dirname \"\$0\")/../..\")\""
    echo ""
  } >> "${build_file}"

  mush_feature_hook "build_debug_head_section" "${build_file}"

  {
    echo "# @build_section: BS003 - Embedding debug api"
    debug_2022
    echo ""
  } >> "${build_file}"

  if [ -n "${lib_file}" ]; then
    {
      echo "# @build_section: BS015 - Appending library"
      echo "debug_file \"\${MUSH_DEBUG_PATH}/${lib_file}\""
    } >> "${build_file}"
  fi

  {
    echo "# @build_section: BS001 - Appending entrypoint to debug build"
    echo "debug init"
    echo "debug file \"\${MUSH_DEBUG_PATH}/${src_file}\""
    echo "main \"\$@\""
  } >> "${build_file}"

  mv "${build_file}" "${final_file}"
  chmod +x "${final_file}"
}

exec_build_lib_debug() {
  local lib_file
  local out_file
  local build_file
  local final_file

  lib_file="$1"
  out_file="$2"

  compile_file "${lib_file}"

  mkdir -p "$(dirname "${out_file}")"

  build_file="${out_file}.tmp"
  final_file="${out_file}"

  echo "debug init" >> "${build_file}"
  echo "debug file \"\${lib_file}\"" >> "${build_file}"

  mv "${build_file}" "${final_file}"
}

exec_build_release() {
  local target_path

  target_path=${1:-target/release}

  name=$MUSH_PACKAGE_NAME

  #echo "NAME: $name"

  local bin_file=bin/${name}

  local build_date=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  local build_file=target/release/${name}.tmp
  local final_file=target/release/${name}

  mkdir -p target/release

  echo "#!/usr/bin/env bash" > $build_file
  echo "# @BP010: Release metadata" >> "${build_file}"
  echo "# @package: ${name}" >> "${build_file}"
  echo "# @build_type: bin" >> "${build_file}"
  echo "# @build_with: ${VERSION}" >> "${build_file}"
  echo "# @build_date: ${build_date}" >> "${build_file}"

  echo "set -e" >> $build_file

  release_2022 >> $build_file

  echo "## BP004: Compile the entrypoint" >> "${build_file}"
  compile_file "src/main.sh" "${build_file}" "" "release"

  echo "## BP005: Execute the entrypoint" >> "${build_file}"
  echo "main \"\$@\"" >> "${build_file}"

  ## Generate binary on target
  cp "${build_file}" "${final_file}"
  chmod +x "${final_file}"
  rm -f "${build_file}"

  ## Generate binary on root
  mkdir -p bin/
  cp "${final_file}" "${bin_file}"
  chmod +x "${bin_file}"
}

exec_build_from_src() {
  local package_src=$1

  if [ -f "${package_src}/src/lib.sh" ]; then
    exec_build_lib_from_src "${package_src}"
  fi

  #echo "PROCESS BIN ${package_src}"

  if [ -f "${package_src}/src/main.sh" ]; then
    exec_build_bin_from_src "${package_src}"
  fi
}

exec_build_bin_from_src() {
  local package_src=$1
  local package_name=$MUSH_PACKAGE_NAME
  #echo "NAME: $name"
  local bin_file=${package_src}/bin/${package_name}
  local build_date=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  local build_file=${package_src}/target/release/${package_name}.tmp
  local final_file=${package_src}/target/release/${package_name}

  mkdir -p "${package_src}/target/release"

  echo "#!/usr/bin/env bash" > $build_file
  echo "## BP010: Release metadata" >> "${build_file}"
  echo "## @build_type: bin" >> "${build_file}"
  echo "## @build_date: ${build_date}" >> "${build_file}"

  echo "set -e" >> $build_file

  release_2022 >> $build_file

  echo "## BP004: Compile the entrypoint" >> "${build_file}"
  compile_file "${package_src}/src/main.sh" "${build_file}"

  echo "## BP005: Execute the entrypoint" >> "${build_file}"
  echo "main \"\$@\"" >> "${build_file}"

  ## Generate binary on target
  cp "${build_file}" "${final_file}"
  chmod +x "${final_file}"
  rm -f "${build_file}"

  ## Generate binary on root
  mkdir -p "${package_src}/bin/"
  cp "${final_file}" "${bin_file}"
  chmod +x "${bin_file}"
}

exec_build_lib_from_src() {
  local package_src=$1
  local package_name=$MUSH_PACKAGE_NAME
  #echo "NAME: $name"
  local lib_file=${package_src}/lib/${package_name}
  local build_date=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  local build_file=${package_src}/target/releaselib.sh.tmp
  local final_file=${package_src}/target/releaselib.sh

  mkdir -p "${package_src}/target/release"

  echo "#!/usr/bin/env bash" > $build_file
  echo "## BP010: Release metadata" >> "${build_file}"
  echo "## @build_type: lib" >> "${build_file}"
  echo "## @build_date: ${build_date}" >> "${build_file}"

  echo "set -e" >> $build_file

  release_2022 >> $build_file

  echo "## BP004: Compile the entrypoint" >> "${build_file}"
  compile_file "${package_src}/src/lib.sh" "${build_file}" "${package_src}" "release"

  ## Generate binary on target
  cp "${build_file}" "${final_file}"
  chmod +x "${final_file}"

  ## Generate binary on root
  mkdir -p "${package_src}/lib/"
  cp "${final_file}" "${lib_file}"
  chmod +x "${lib_file}"
}

exec_build_test() {
  local name=$MUSH_PACKAGE_NAME

  local build_file=target/debug/bin/test/${name}.tmp
  local final_file=target/debug/bin/test/${name}

  mkdir -p target/debug/bin/test

  compile_file "src/main.sh"

  echo "#!/usr/bin/env bash" > "${build_file}"
  echo "set -e" >> "${build_file}"
  echo "" >> "${build_file}"

  MUSH_DEBUG_PATH=${PWD}
  echo "## BP002: Package and debug variables " >> "${build_file}"
  echo "MUSH_PACKAGE_NAME=${name}" >> "${build_file}"
  echo "MUSH_DEBUG_PATH=${MUSH_DEBUG_PATH}" >> "${build_file}"
  echo "MUSH_TARGET_PATH=\"\${MUSH_DEBUG_PATH}/target/debug\"" >> "${build_file}"
  echo "" >> "${build_file}"

  echo "## BP003: Embedding debug api" >> "${build_file}"
  debug_2022 >> "${build_file}"
  echo "" >> "${build_file}"

  echo "## BP012: Embedding test api" >> "${build_file}"
  test_2022 >> "${build_file}"
  echo "" >> "${build_file}"

  echo "## BP001: Appending entrypoint to debug build" >> "${build_file}"
  echo "debug_file \"\${MUSH_DEBUG_PATH}/src/main.sh\"" >> "${build_file}"
  echo "mush_api_test_2022 \"\$@\"" >> "${build_file}"

  mv "${build_file}" "${final_file}"
  chmod +x "${final_file}"
}

exec_init() {
  local package_name=$(basename "$PWD")
  local manifest_file=Manifest.toml
  local main_file=src/main.sh
  local lib_file=src/lib.sh

  mkdir -p src

  echo "[package]" > ${manifest_file}
  echo "name = \"${package_name}\"" >> ${manifest_file}
  echo "version = \"0.1.0\"" >> ${manifest_file}
  echo "edition = \"2022\"" >> ${manifest_file}
  echo "" >> ${manifest_file}
  echo "# See more keys and their definitions at https://mush.javanile.org/manifest.html" >> ${manifest_file}
  echo "" >> ${manifest_file}
  echo "[dependencies]" >> ${manifest_file}

  if [ ! -f "${main_file}" ]; then
    echo "" > ${main_file}
    echo "main() {" >> ${main_file}
    echo "  echo \"Hello World!\"" >> ${main_file}
    echo "}" >> ${main_file}
  fi

  console_status "Created" "binary (application) package"
}

exec_install_binaries() {
  echo "${MUSH_BINARIES}"

  local binaries
  local bin_name
  local bin_path
  local tmp_ifs

  binaries="${MUSH_BINARIES}"

  for bin in $binaries; do
    bin_name=""
    bin_path=""

    tmp_ifs=$IFS
    IFS=','
    for field in ${bin}; do
      case "$field" in
        name=*)
          bin_name="${field#name=}"
          ;;
        path=*)
          bin_path="${field#path=}"
          ;;
      esac
    done
    IFS=$tmp_ifs

    echo "name: $bin_name, path: $bin_path"
  done
}


exec_install() {
  local package_name
  local package_version
  local bin_name
  local pwd=$PWD
  local bin_file
  local final_file
  local cp
  local chmod

  package_name=$MUSH_PACKAGE_NAME
  package_version=$MUSH_PACKAGE_VERSION
  bin_name=$MUSH_PACKAGE_NAME
  pwd="${PWD}"
  bin_file="${MUSH_HOME}/bin/${bin_name}"
  final_file=target/release/${bin_name}
  cp="cp"
  chmod="chmod"

  #if [[ $EUID -ne 0 ]]; then
  #    cp="sudo ${cp}"
  #    chmod="sudo ${chmod}"
  #fi

  mkdir -p "${MUSH_HOME}/bin"
  ${cp} "${final_file}" "${bin_file}"
  ${chmod} +x "${bin_file}"

  console_status "Finished" "release [optimized] target(s) in 0.18s"

  if [ -f "${bin_file}" ]; then
    console_status "Replacing" "${bin_file}"
    console_status "Replaced" "package '${package_name} v${package_version} (${pwd})' with '${package_name} v${package_version} (${pwd})' (executable '${bin_name}')"
  else
    console_status "Installing" "${bin_file}"
    console_status "Installed" "package '${package_name} v${package_version} (${pwd})' (executable '${bin_name}')"
  fi
}

exec_install_from_index() {
  local package_entry
  local package_name
  local package_url
  #local package_version_constraint
  local dependency_type
  local package_path
  local package_version
  #local package_version_selected
  local package_src
  local package_search
  local package_type

  package_name=$1
  #package_version_constraint=$2
  dependency_type=$3

  package_search=$(grep "^${package_name} " "${MUSH_REGISTRY_INDEX}" | head -n 1)

  if [ -z "${package_search}" ]; then
    console_error "could not find '${package_name}' in registry '${MUSH_REGISTRY_URL}' with version '*'"
    exit 101
  fi

  ## TODO: Implement version constraint
  #package_version_selected=1

  package_entry=$(echo "${package_search}" | cut -d'#' -f1)
  package_name=$(echo "${package_entry}" | awk '{print $1}')
  package_url=$(echo "${package_entry}" | awk '{print $2}')
  package_path=$(echo "${package_entry}" | awk '{print $3}')
  package_version=$(echo "${package_entry}" | awk '{print $4}')

  package_version=main

  package_src="${MUSH_REGISTRY_SRC}/${package_name}/${package_version}"

  if [ ! -d "${package_src}" ]; then

    [ "${VERBOSE}" -gt 4 ] && echo "Cloning: ${package_url}"

    git clone --branch main --single-branch "${package_url}" "${package_src}" > /dev/null 2>&1 && true

    if [ ! -d "${package_src}" ]; then
      console_error "failed to retrieve '${package_name}' at version '${package_version}' from '${package_url}'"
      exit 101
    fi

    rm -fr "${package_src}/.git" "${package_src}/.github" || true
  fi

  local package_nested_src="${MUSH_REGISTRY_SRC}/${package_name}/${package_version}/${package_path}"

  exec_install_from_src "${package_nested_src}" "${dependency_type}"

  package_type=$(cat "${package_nested_src}/Manifest.toml" | grep '^type =' | cut -d'"' -f2)

  echo "package_type=${package_type}"

  if [ "${package_type}" = "plugin" ]; then
    mkdir -p "${MUSH_HOME}/plugins/${package_name}"
    cp "${package_nested_src}/src/lib.sh" "${MUSH_HOME}/plugins/${package_name}/plugin.sh"
    cp "${package_nested_src}/Manifest.toml" "${MUSH_HOME}/plugins/${package_name}/Manifest.toml"
  fi
}

exec_install_from_src() {
  local package_src
  local dependency_type

  package_src=$1
  dependency_type=$2

  exec_manifest_lookup "${package_src}"

  [ "${VERBOSE}" -gt 6 ] && echo "Installing '${MUSH_PACKAGE_NAME}' from source '${package_src}' for '${dependency_type}'"

  if [ "${MUSH_PACKAGE_TYPE}" = "plugin" ] && [ "${dependency_type}" = "prod" ]; then
    console_error "cannot install plugin '${MUSH_PACKAGE_NAME}' as a non dev-dependency, move it from [dependencies] to [dev-dependencies] in your Manifest.toml file."
    exit 101
  fi

  exec_legacy_fetch "${package_src}/target/release"
  exec_legacy_build "${package_src}/target/release"

  if [ -f "${package_src}/src/lib.sh" ]; then
    exec_install_lib_from_src "${package_src}"
  fi

  if [ -f "${package_src}/src/main.sh" ]; then
    exec_install_bin_from_src "${package_src}"
  fi
}

exec_install_bin_from_src() {
  local package_src=$1
  local package_name=$MUSH_PACKAGE_NAME
  local package_version=$MUSH_PACKAGE_VERSION
  local bin_name=$MUSH_PACKAGE_NAME
  local pwd=$PWD

  local bin_file=$HOME/.mush/bin/${bin_name}
  local final_file=${package_src}/target/release/${bin_name}

  local cp=cp
  local chmod=chmod
  #if [[ $EUID -ne 0 ]]; then
  #    cp="sudo ${cp}"
  #    chmod="sudo ${chmod}"
  #fi

  ${cp} "${final_file}" "${bin_file}"
  ${chmod} +x "${bin_file}"

  console_status "Finished" "release [optimized] target(s) in 0.18s"

  if [ -f "${bin_file}" ]; then
    console_status "Replacing" "${bin_file}"
    console_status "Replaced" "package '${package_name} v${package_version} (${pwd})' with '${package_name} v${package_version} (${pwd})' (executable '${bin_name}')"
  else
    console_status "Installing" "${bin_file}"
    console_status "Installed" "package '${package_name} v${package_version} (${pwd})' (executable '${bin_name}')"
  fi
}

exec_install_lib_from_src() {
  local package_src=$1
  local package_name=$MUSH_PACKAGE_NAME
  local package_version=$MUSH_PACKAGE_VERSION
  local lib_name=$MUSH_PACKAGE_NAME
  local pwd=$PWD

  local lib_file=${pwd}/lib/${lib_name}
  local lib_package_dir=${pwd}/${MUSH_TARGET_PATH}/packages/${lib_name}
  local lib_package_file=${lib_package_dir}/lib.sh
  local lib_plugin_dir=${pwd}/${MUSH_TARGET_PATH}/plugins
  local lib_plugin_file=${lib_plugin_dir}/${lib_name}.sh
  local final_file=${package_src}/target/releaselib.sh

  local cp=cp
  local chmod=chmod
  #if [[ $EUID -ne 0 ]]; then
  #    cp="sudo ${cp}"
  #    chmod="sudo ${chmod}"
  #fi

  mkdir -p "${pwd}/lib" "${lib_package_dir}"

  ${cp} "${final_file}" "${lib_file}"
  ${cp} "${final_file}" "${lib_package_file}"

  ${chmod} +x "${lib_file}" "${lib_package_file}"

  if [ "${MUSH_PACKAGE_TYPE}" = "plugin" ]; then
    mkdir -p "${lib_plugin_dir}"
    ${cp} "${final_file}" "${lib_plugin_file}"
    ${chmod} +x "${lib_plugin_file}"
  fi

  console_status "Finished" "release [optimized] target(s) in 0.18s"

  if [ -f "${lib_file}" ]; then
    console_status "Replacing" "${lib_file}"
    console_status "Replaced" "package '${package_name} v${package_version} (${pwd})' with '${package_name} v${package_version} (${pwd})' (library '${lib_name}')"
  else
    console_status "Installing" "${lib_file}"
    console_status "Installed" "package '${package_name} v${package_version} (${pwd})' (library '${lib_name}')"
  fi
}

exec_legacy_fetch() {
  local target_dir=$1
  local legacy_dir="${target_dir}/legacy"

  echo "${MUSH_LEGACY_FETCH}" | while IFS=$'\n' read -r package && [ -n "$package" ]; do
    package_name=${package%=*}
    package_bin=${legacy_dir}/${package_name}
    package_signature=${package#*=}
    package_type=${package_signature%% *}
    package_url=${package_signature#* }

    [ "${VERBOSE}" -gt 4 ] && echo "Process legacy source of type '$package_type' with url '$package_url' for '$package_name'"

    case "${package_type}" in
      git)
        echo "NOT IMPLEMENTED YET!"
        exit 101
        ;;
      file)
        package_file=${legacy_dir}/${package_name}.sh
        if [ ! -f "${package_file}" ]; then
          console_status "Downloading" "$package_name => $package_url ($package_file)"
          mkdir -p "${legacy_dir}"
          curl -s -L -X GET -o "${package_file}" "${package_url}"
          ln "${package_file}" "${package_bin}"
          chmod +x "${package_bin}"
        fi
        ;;
      *)
        console_error "Unsupported legacy package type '$package_type' for '$package_name' on Manifest.toml"
        exit 101
        ;;
    esac
  done
}
# @score: 5

exec_legacy_build() {
  local target_dir
  local legacy_dir
  local temp_pwd

  target_dir=$1
  legacy_dir="${target_dir}/legacy"

  [ "${VERBOSE}" -gt 5 ] && echo -e "FETCH:\n${MUSH_LEGACY_FETCH}\nBUILD:\n${MUSH_LEGACY_BUILD}"

  echo "${MUSH_LEGACY_BUILD}" | while IFS=$'\n' read -r package && [ -n "$package" ]; do
    package_name=${package%=*}
    package_file=${legacy_dir}/__${package_name}.sh
    package_script=${package#*=}

    [ "${VERBOSE}" -gt 4 ] && echo "! Building '${package_script}' for '$package_name'"

    if [ ! -f "${package_file}" ]; then
      console_status "Compiling" "$package_name => $package_script ($package_file)"
      mkdir -p "${legacy_dir}"
      temp_pwd=$PWD
      cd "$legacy_dir" || exit 101
      eval "PATH=${PATH}:${PWD} ${package_script}"
      cd "$temp_pwd" || exit 101
    fi
  done
}

exec_manifest_lookup() {
  local manifest_dir

  manifest_dir=$1

  if [ ! -f "${manifest_dir}/Manifest.toml" ]; then
    console_error "could not find 'Manifest.toml' in '${manifest_dir}' or any parent directory"
    exit 101
  fi

  MUSH_MANIFEST_DIR="${manifest_dir}"

  manifest_parse "${manifest_dir}/Manifest.toml"

  if [ -z "$MUSH_PACKAGE_VERSION" ]; then
    console_error "failed to parse manifest at '$manifest_dir/Manifest.toml'\n\nCaused by:\n  missing field 'version' for key 'package'"
    exit 101
  fi

  if [ ! -f "${manifest_dir}/src/lib.sh" ] && [ ! -f "${manifest_dir}/src/main.sh" ]; then
    console_error "failed to parse manifest at '${manifest_dir}/Manifest.toml'\n\nCaused by:\n  no targets specified in the manifest\n  either src/lib.sh, src/main.sh, a [lib] section, or [[bin]] section must be present"
    exit 101
  fi

  MUSH_PACKAGE_TYPE="${MUSH_PACKAGE_TYPE:-lib}"

  MUSH_FEATURES=$(printf "%s\n" "$MUSH_FEATURES" | \
      sed '/^$/d' | \
      tac | \
      sort -t= -k1,1 -u | \
      tac
  )
}

manifest_parse() {
  local manifest_file=$1

    #echo "S:"
    newline='
'
    section=MUSH_USTABLE
    while IFS= read -r line || [ -n "${line}" ]; do
      line="${line#"${line%%[![:space:]]*}"}"
      line="${line%"${line##*[![:space:]]}"}"
      line_number=$((line_number + 1))
      [ -z "${line}" ] && continue
      [ "$(printf '%s' "$line" | cut -c1)" = "#" ] && continue
      case $line in
        "[package]")
          section=MUSH_PACKAGE
          ;;
        "[dependencies]")
          section=MUSH_DEPS
          ;;
        "[dev-dependencies]")
          section=MUSH_DEV_DEPS
          ;;
        "[build-dependencies]")
          section=MUSH_BUILD_DEPS
          ;;
        "[legacy-fetch]")
          section=MUSH_LEGACY_FETCH
          ;;
        "[legacy-build]")
          section=MUSH_LEGACY_BUILD
          ;;
        "[dev-legacy-fetch]")
          section=MUSH_DEV_LEGACY_FETCH
          ;;
        "[dev-legacy-build]")
          section=MUSH_DEV_LEGACY_BUILD
          ;;
        "[features]")
          section=MUSH_FEATURES
          ;;
        "[[bin]]")
          section=MUSH_BINARIES
          MUSH_BINARIES="${MUSH_BINARIES}${newline}"
          ;;
        [a-z]*)
          case $section in
            MUSH_PACKAGE)
              field=$(echo "$line" | cut -d'=' -f1 | xargs | awk '{ print toupper($0) }')
              value=$(echo "$line" | cut -d'=' -f2 | xargs)
              eval "${section}_${field}=\$value"
              ;;
            MUSH_LEGACY_FETCH)
              package=$(echo "$line" | cut -d'=' -f1 | xargs | tr '-' '_')
              url=$(echo "$line" | cut -d'=' -f2 | xargs)
              MUSH_LEGACY_FETCH="${MUSH_LEGACY_FETCH}${package}=${url}${newline}"
              ;;
            MUSH_LEGACY_BUILD)
              package=$(echo "$line" | cut -d'=' -f1 | xargs | tr '-' '_')
              script=$(echo "$line" | cut -d'=' -f2 | xargs)
              MUSH_LEGACY_BUILD="${MUSH_LEGACY_BUILD}${package}=${script}${newline}"
              ;;
            MUSH_DEPS)
              package=$(echo "$line" | cut -d'=' -f1 | xargs | tr '-' '_')
              signature=$(echo "$line" | cut -d'=' -f2 | xargs)
              MUSH_DEPS="${MUSH_DEPS}${package}=${signature}${newline}"
              ;;
            MUSH_DEPS_BUILD)
              package=$(echo "$line" | cut -d'=' -f1 | xargs | tr '-' '_')
              script=$(echo "$line" | cut -d'=' -f2 | xargs)
              MUSH_DEPS_BUILD="${MUSH_DEPS_BUILD}${package}=${script}${newline}"
              ;;
            MUSH_DEV_DEPS)
              package=$(echo "$line" | cut -d'=' -f1 | xargs | tr '-' '_')
              signature=$(echo "$line" | cut -d'=' -f2 | xargs)
              MUSH_DEV_DEPS="${MUSH_DEV_DEPS}${package}=${signature}${newline}"
              ;;
            MUSH_DEV_DEPS_BUILD)
              package=$(echo "$line" | cut -d'=' -f1 | xargs | tr '-' '_')
              script=$(echo "$line" | cut -d'=' -f2 | xargs)
              MUSH_DEV_DEPS_BUILD="${MUSH_DEV_DEPS_BUILD}${package}=${script}${newline}"
              ;;
            MUSH_FEATURES)
              feature=$(echo "$line" | cut -d'=' -f1 | xargs | tr '-' '_')
              value=$(echo "$line" | cut -d'=' -f2 | xargs)
              MUSH_FEATURES="${MUSH_FEATURES}${feature}=${value}${newline}"
              #eval "${section}_${field}=\$value"
              ;;
            MUSH_BINARIES)
              field=$(echo "$line" | cut -d'=' -f1 | xargs | tr '-' '_')
              value=$(echo "$line" | cut -d'=' -f2 | xargs)
              MUSH_BINARIES="${MUSH_BINARIES}${field}=${value},"
              #eval "${section}_${field}=\$value"
              ;;
            *)
              ;;
          esac
          ;;
        *)
          ;;
      esac
      #echo "L: $line"
    done < "${manifest_file}"
    #echo "E."
}



compile_file() {
  local src_file
  local build_file
  local manifest_directory
  local build_mode

  src_file=$1
  build_file=$2
  manifest_directory=${3:-$PWD}
  build_mode=${4:-debug}

  [ "${VERBOSE}" -gt 5 ] && echo "Compile file '${src_file}' for '${build_mode}' to '${build_file}' from '${manifest_directory}'"

  # Analyze file for syntax errors
  bash -n "${src_file}"

  mush_feature_hook compile_file "${src_file}"

  if [ -n "${build_file}" ]; then
    cat "${src_file}" >> "${build_file}"
    #sed '/^[[:space:]]*$/d' "${src_file}" >> "${build_file}"
  fi

  compile_scan_legacy "${src_file}" "${build_file}" "${manifest_directory}" "${build_mode}"

  compile_scan_public "${src_file}" "${build_file}" "${manifest_directory}" "${build_mode}"

  compile_scan_module "${src_file}" "${build_file}" "${manifest_directory}" "${build_mode}"

  compile_scan_extern_package "${src_file}" "${build_file}" "${manifest_directory}" "${build_mode}"

  compile_scan_embed "${src_file}" "${build_file}" "${manifest_directory}" "${build_mode}"
}

compile_scan_legacy() {
  local src_file=$1
  local build_file=$2
  local legacy_dir=$3/target/$4/legacy

  grep -n '^legacy [a-z][a-z0-9_]*$' "${src_file}" | while read -r line; do
    local legacy_name=$(echo "${line#*legacy}" | xargs)
    local legacy_file="${legacy_dir}/__${legacy_name}.sh"
    local legacy_dir_file="${legacy_dir}/${legacy_name}/__${legacy_name}.sh"
    #echo "LEGACY: $legacy_file"
    if [ -e "${legacy_file}" ]; then
      console_info "Legacy" "file '${legacy_file}' as module file"
      if [ -n "${build_file}" ]; then
        #cat "${legacy_file}" >> "${build_file}"
        sed '/^[[:space:]]*$/d' "${legacy_file}" >> "${build_file}"
      fi
    elif [ -e "${legacy_dir_file}" ]; then
      console_info "Legacy" "file '${public_dir_file}' as directory module file"
    else
      console_error "file not found for module '${legacy_name}'. Look at '${src_file}' on line ${line%:*}"
      console_log  "To add the module '${legacy_name}', type 'mush legacy --name ${legacy_name} <MODULE_URL>'."
      exit 101
    fi
  done

  return 0
}

compile_scan_public() {
  local src_file=$1
  local build_file=$2
  local public_dir=$(dirname "$src_file")

  grep -n '^public [a-z][a-z0-9_]*$' "${src_file}" | while read -r line; do
    local public_name=$(echo "${line#*public}" | xargs)
    local public_file="${public_dir}/${public_name}.sh"
    local public_dir_file="${public_dir}/${public_name}/module.sh"

    if [ -e "${public_file}" ]; then
      console_info "Public" "file '${public_file}' as module file"
      compile_file "${public_file}" "${build_file}"
    elif [ -e "${public_dir_file}" ]; then
      console_info "Public" "file '${public_dir_file}' as directory module file"
      compile_file "${public_dir_file}" "${build_file}"
    else
      console_error "File not found for module '${public_name}'. Look at '${src_file}' on line ${line%:*}"
      console_log  "To create the module '${public_name}', create file '${public_file}' or '${public_dir_file}'."
      exit 101
    fi
  done

  return 0
}

compile_scan_module() {
  local src_file=$1
  local build_file=$2
  local module_dir=$(dirname "$src_file")
  local root_src_file

  grep -n '^module [a-z][a-z0-9_]*$' "${src_file}" | while read -r line; do
    root_src_file=

    local module_name=$(echo "${line#*module}" | xargs)
    local module_file="${module_dir}/${module_name}.sh"
    local module_dir_file="${module_dir}/${module_name}/module.sh"

    if [ "${module_dir}" = "examples" ]; then
      [ -f "src/${module_name}.sh" ] && root_src_file="src/${module_name}.sh"
      [ -f "src/${module_name}/module.sh" ] && root_src_file="src/${module_name}/module.sh"
    fi

    if [ -e "${module_file}" ]; then
      console_info "Import" "file '${module_file}' as module file"
      compile_file "${module_file}" "${build_file}"
    elif [ -e "${module_dir_file}" ]; then
      console_info "Import" "file '${module_dir_file}' as directory module file"
      compile_file "${module_dir_file}" "${build_file}"
    elif [ -n "${root_src_file}" ]; then
      console_info "Import" "file '${root_src_file}' as module file"
      compile_file "${root_src_file}" "${build_file}"
    else
      console_error "File not found for module '${module_name}'. Look at '${src_file}' on line ${line%:*}"
      console_log  "To create the module '${module_name}', create file '${module_file}' or '${module_dir_file}'."
      error_E0583_file_not_found "${module_name}" "${src_file}" "${line%:*}"
      exit 101
    fi
  done

  return 0
}

compile_scan_extern_package() {
  local src_file=$1
  local build_file=$2
  local module_dir=$(dirname "${src_file}")
  local extern_package_dir=${MUSH_TARGET_PATH}

  grep -n '^extern package [a-z][a-z0-9_]*$' "${src_file}" | while read -r line; do
    local package_name=$(echo "${line#*package}" | xargs)
    local package_file="${extern_package_dir}/packages/${package_name}/lib.sh"
    if [ -e "${package_file}" ]; then
      console_info "Import" "file '${package_file}' as package file"
      if [ -n "${build_file}" ]; then
        #cat "${package_file}" >> "${build_file}"
        sed '/^[[:space:]]*$/d' "${package_file}" >> "${build_file}"
      fi
    else
      [ "${VERBOSE}" -gt 6 ] && echo "File not found: ${package_file} (package_dir: ${extern_package_dir})"
      error_package_not_found "${package_name}" "${src_file}" "${line%:*}"
      #console_error "File not found for package '${package_name}'. Look at '${src_file}' on line ${line%:*}"
      #console_log  "To create the module '${module_name}', create file '${module_file}' or '${module_dir_file}'."
      exit 101
    fi
  done

  return 0
}

compile_scan_embed() {
  local src_file=$1
  local build_file=$2
  local module_dir=$(dirname "$src_file")

  grep -n '^embed [a-z][a-z0-9_]*$' "${src_file}" | while read -r line; do
    local module_name=$(echo "${line#*embed}" | xargs)
    local module_file="${module_dir}/${module_name}.sh"
    local module_dir_file="${module_dir}/${module_name}/module.sh"

    if [ -e "${module_file}" ]; then
      console_info "Embed" "file '${module_file}' as module file"
      if [ -n "$build_file" ]; then
        mush_api_2022_embed "$module_name" "$module_file" >> "${build_file}"
      fi
    else
      console_error "File not found for module '${module_name}'. Look at '${src_file}' on line ${line%:*}"
      console_log  "To create the module '${module_name}', create file '${module_file}'."
      exit 101
    fi
  done

  return 0
}

exec_publish() {
  local bin_name
  local bin_file
  local final_file
  local package_name
  local release_tag

  bin_name=${MUSH_PACKAGE_NAME}
  bin_file=/usr/local/bin/${bin_name}
  final_file=target/release/${bin_name}
  package_name="${MUSH_PACKAGE_NAME}"
  release_tag="${MUSH_PACKAGE_VERSION}"

  MUSH_GITHUB_REPOSITORY="$(github_get_repository)"

  ## TODO: add the following message when an index will be implemented
  # Updating crates.io index

  console_status "Updating" Mush packages index

  if [ -z "${GITHUB_TOKEN}" ]; then
    console_error "no token found, input it manually or use environment variable GITHUB_TOKEN"
    echo
    echo "please paste the token found on https://github.com/settings/tokens below"
    read -r GITHUB_TOKEN
    [ -z "${GITHUB_TOKEN}" ] && exit 101
    export GITHUB_TOKEN="${GITHUB_TOKEN}"
  fi

  ## TODO: add the following message when no stuff
  # warning: manifest has no documentation, homepage or repository.
  # See https://mush.javanile.org/manifest.html#package-metadata for more info.

  if [ -n "${ALLOW_DIRTY}" ]; then
    git add .
    git commit -am "Allow dirty"
  fi

  if [ ! -z "$(git status --porcelain)" ]; then
    local changed_files="$(git status -s | cut -c4-)"
    local error="some files in the working directory contain changes that were not yet committed into git:"
    local hint="to proceed despite this and include the uncommitted changes, pass the '--allow-dirty' flag"
    console_error "$error\n\n${changed_files}\n\n${hint}"
    exit 101
  fi

  #    Updating crates.io index
  # warning: manifest has no documentation, homepage or repository.
  # See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
  #   Packaging cask-cli v0.2.0 (/Users/francescobianco/Develop/Javanile/rust-cask)
  #   Verifying cask-cli v0.2.0 (/Users/francescobianco/Develop/Javanile/rust-cask)
  #  Downloaded rand_core v0.6.4
  #  Downloaded 9 crates (2.5 MB) in 1.90s (largest was `run_script` at 1.1 MB)
  #   Compiling serde_yaml v0.9.14
  #   Compiling cask-cli v0.2.0 (/Users/francescobianco/Develop/Javanile/rust-cask/target/package/cask-cli-0.2.0)
  #    Finished dev [unoptimized + debuginfo] target(s) in 13.89s
  #   Uploading cask-cli v0.2.0 (/Users/francescobian

#    Updating crates.io index
#warning: manifest has no documentation, homepage or repository.
#See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
#   Packaging rust-app v0.1.0 (/home/francesco/Develop/Javanile/mush/tests/fixtures/rust-app)
#   Verifying rust-app v0.1.0 (/home/francesco/Develop/Javanile/mush/tests/fixtures/rust-app)
#   Compiling rust-app v0.1.0 (/home/francesco/Develop/Javanile/mush/tests/fixtures/rust-app/target/package/rust-app-0.1.0)
#    Finished dev [unoptimized + debuginfo] target(s) in 1.77s
#    Packaged 37 files, 12.0MiB (2.9MiB compressed)
#   Uploading rust-app v0.1.0 (/home/francesco/Develop/Javanile/mush/tests/fixtures/rust-app)
#    Uploaded rust-app v0.1.0 to registry `crates-io`
#note: Waiting for `rust-app v0.1.0` to be available at registry `crates-io`.
#You may press ctrl-c to skip waiting; the crate should be available shortly.
#   Published rust-app v0.1.0 at registry `crates-io`

  [ -f .env ] && source .env

  ## Create or update the git tag
  git tag -f -a "$release_tag" -m "Tag $release_tag" > /dev/null 2>&1
  git push origin "$release_tag" -f > /dev/null 2>&1

  release_id="$(github_get_release_id "${release_tag}")"

  if [ -z "${release_id}" ]; then
    release_id=$(github_create_release "${release_tag}")
  fi

  asset_id="$(github_get_release_asset_id "${release_id}" "${final_file}")"

# error: failed to publish to registry at https://crates.io
#
# Caused by:
#   the remote server responded with an error: crate version `0.1.0` is already uploaded

  if [ -n "${asset_id}" ]; then
    github_delete_release_asset "${asset_id}"
  fi

  console_status "Uploading" "${package_name} v${release_tag} ($PWD)"

  download_url="$(github_upload_release_asset "${release_id}" "${final_file}")"

  console_status "Uploaded" "${package_name} v${release_tag} to registry at ${download_url}"
}
# @score: 5

exec_plugin_list() {
  local plugins_dir
  local plugin_file
  local plugin_name

  # Global installed plugin
  plugins_dir="${MUSH_HOME}/plugins"
  if [ -d "$plugins_dir" ]; then
    find "$plugins_dir" -type f -name "plugin.sh" | while IFS=$'\n' read -r plugin_file; do
      plugin_name="$(basename "$(dirname "${plugin_file}")")"
      echo "${plugin_name}=${plugin_file}"
    done
  fi

  # Project related plugin
  plugins_dir="$1/plugins"
  if [ -d "$plugins_dir" ]; then
    find "$plugins_dir" -type f -name "plugin.sh" | while IFS=$'\n' read -r plugin_file; do
      echo "Found plugin: ${plugin_file}" >&2
      plugin_name="$(basename "$(dirname "${plugin_file}")")"
      echo "${plugin_name}=${plugin_file}"
    done
  fi
}

exec_dependencies() {
  local update_strategy
  ## TODO: Expected output
  #  Downloaded syn v2.0.37
  #  Downloaded 1 crate (243.2 KB) in 0.46s
  #   Compiling proc-macro2 v1.0.67
  #   Compiling unicode-ident v1.0.12
  #   Compiling serde v1.0.188
  #   Compiling quote v1.0.33
  #   Compiling syn v2.0.37
  #   Compiling serde_derive v1.0.188
  #   Compiling rust-lib v0.1.0 (/home/francesco/Develop/Javanile/mush/tests/fixtures/rust-lib)
  #    Finished dev [unoptimized + debuginfo] target(s) in 4.65s

  update_strategy="${1:-lazy}"

  process_dependencies "dev" "${update_strategy}"
  process_dependencies_build "dev"

  process_dependencies "prod" "${update_strategy}"
  process_dependencies_build "prod"
}

process_dependencies() {
  local dependencies_type
  local dependencies_list
  local package_name
  local package_signature
  local update_strategy

  dependencies_type=$1
  if [ "${dependencies_type}" = "prod" ]; then
    dependencies_list="${MUSH_DEPS}"
  else
    dependencies_list="${MUSH_DEV_DEPS}"
  fi

  update_strategy="${2:-lazy}"

  echo "${dependencies_list}" | while IFS=$'\n' read -r dependency && [ -n "$dependency" ]; do
    [ "${VERBOSE}" -gt 4 ] && echo "Parsing dependency '$dependency'"

    package_name="${dependency%=*}"
    package_signature="${dependency#*=}"

    if [ ! -d "${MUSH_DEPS_DIR}/${package_name}" ]; then
      process_dependency "${dependencies_type}" "${package_name}" "${package_signature}" "${update_strategy}"
    fi
  done
}

process_dependency() {
  local dependency_type
  local package_name
  local package_source
  local package_full_name
  local package_version_constraint

  dependency_type="$1"
  package_name="$2"

  if [ "$3" = "*" ]; then
    package_source="mush"
    package_full_name="${package_name}"
    package_version_constraint="*"
  else
    package_source="${3%% *}"
    package_full_name=$(echo "$3" | awk '{print $2}')
    package_version_constraint=$(echo "$3" | awk '{print $3}')
  fi

  update_strategy=${1:-lazy}

  [ "${VERBOSE}" -gt 4 ] && echo "Processing '$1' dependency '$2', '$3', 'source=${package_source}'"

  case "${package_source}" in
    git)
      git_dependency "${package_name}" "${package_full_name}" "${package_version_constraint}" "${dependency_type}"
      ;;
    mush)
      mush_dependency "${package_name}" "${package_full_name}" "${package_version_constraint}" "${dependency_type}" "${update_strategy}"
      ;;
    path)
      mush_path_dependency "${package_name}" "${package_full_name}" "${package_version_constraint}" "${dependency_type}" "${update_strategy}"
      ;;
    bpkg)
      bpkg_dependency "${package_name}" "${package_full_name}" "${package_version_constraint}" "${dependency_type}"
      ;;
    *)
      console_error "Unsupported package manager '${package_source}' for '$1' on Manifest.toml"
      exit 101
      ;;
  esac
}

process_dependencies_build() {
  local dependencies_type
  local dependencies_build

  dependencies_type=$1
  if [ "${dependencies_type}" = "prod" ]; then
    dependencies_build="${MUSH_DEPS_BUILD}"
  else
    dependencies_build="${MUSH_DEV_DEPS_BUILD}"
  fi

  echo "${dependencies_build}" | while IFS=$'\n' read -r dependency && [ -n "$dependency" ]; do
    local package_name=${dependency%=*}
    local package_script=${dependency#*=}
    local package_dir="${MUSH_DEPS_DIR}/${package_name}"

    if [ -d "${package_dir}" ]; then
      local pwd=$PWD
      cd "${package_dir}"
      eval "PATH=${PATH}:${PWD} ${package_script}"
      cd "$pwd"
    fi
  done
}

mush_env() {
  local newline

  newline='
'

  MUSH_HOME="${MUSH_HOME:-$HOME/.mush}"

  MUSH_FEATURES="${MUSH_FEATURES}init=true${newline}"
  MUSH_FEATURES="${MUSH_FEATURES}build=true${newline}"
  MUSH_FEATURES="${MUSH_FEATURES}build_release=true${newline}"

  MUSH_TERM_COLOR="yes"
}

tac() { awk '{ line[NR] = $0 } END { for (i = NR; i > 0; i--) print line[i] }'; }
#!/usr/bin/env bash
## BP010: Release metadata
## @build_type: lib
## @build_date: 2025-05-17T21:54:26Z
set -e
use() { return 0; }
extern() { return 0; }
legacy() { return 0; }
module() { return 0; }
public() { return 0; }
embed() { return 0; }
inject() { return 0; }
## BP004: Compile the entrypoint
# FATAL
# ERROR
# WARNING
# INFO
# DEBUG
# TRACE
# SUCCESS
case "$(uname -s)" in
  Darwin*)
    ESCAPE='\x1B'
    ;;
  Linux|*)
    ESCAPE='\e'
    ;;
esac
#CONSOLE_INDENT="${ESCAPE}[1;33m{Mush}${ESCAPE}[0m"
console_pad() {
  [ "$#" -gt 1 ] && [ -n "$2" ] && printf "%$2.${2#-}s" "$1"
}
console_log() {
  console_print "$1" "$2"
}
console_info() {
  if [ "${VERBOSE}" -gt "0" ]; then
    console_print "${ESCAPE}[1;36m$(console_pad "$1" 12)${ESCAPE}[0m" "$2"
  fi
}
console_warning() {
  console_print "${ESCAPE}[1;33m$(console_pad "$1" 12)${ESCAPE}[0m" "$2"
}
console_status() {
  console_print "${ESCAPE}[1;32m$(console_pad "$1" 12)${ESCAPE}[0m" "$2"
}
console_error() {
  echo -e "${ESCAPE}[1;31merror${ESCAPE}[0m: $1" >&2
}
console_error_code() {
  echo -e "${ESCAPE}[1;31merror[$1]${ESCAPE}[1;39m: $2${ESCAPE}[0m" >&2
}
console_hint() {
  echo -e "${ESCAPE}[1;39m$1${ESCAPE}[0m" >&2
}
console_print() {
  if [ -z "${QUIET}" ]; then
    echo -e "$1 $2" >&2
  fi
}
#!/usr/bin/env bash
## BP010: Release metadata
## @build_type: lib
## @build_date: 2025-05-17T21:54:29Z
set -e
use() { return 0; }
extern() { return 0; }
legacy() { return 0; }
module() { return 0; }
public() { return 0; }
embed() { return 0; }
inject() { return 0; }
## BP004: Compile the entrypoint
legacy getoptions
# [getoptions] License: Creative Commons Zero v1.0 Universal
# https://github.com/ko1nksm/getoptions (v3.3.0)
getoptions() {
	_error='' _on=1 _no='' _export='' _plus='' _mode='' _alt='' _rest='' _def=''
	_flags='' _nflags='' _opts='' _help='' _abbr='' _cmds='' _init=@empty IFS=' '
	[ $# -lt 2 ] && set -- "${1:?No parser definition}" -
	[ "$2" = - ] && _def=getoptions_parse
	i='					'
	while eval "_${#i}() { echo \"$i\$@\"; }"; [ "$i" ]; do i=${i#?}; done
	quote() {
		q="$2'" r=''
		while [ "$q" ]; do r="$r${q%%\'*}'\''" && q=${q#*\'}; done
		q="'${r%????}'" && q=${q#\'\'} && q=${q%\'\'}
		eval "$1=\${q:-\"''\"}"
	}
	code() {
		[ "${1#:}" = "$1" ] && c=3 || c=4
		eval "[ ! \${$c:+x} ] || $2 \"\$$c\""
	}
	sw() { sw="$sw${sw:+|}$1"; }
	kv() { eval "${2-}${1%%:*}=\${1#*:}"; }
	loop() { [ $# -gt 1 ] && [ "$2" != -- ]; }
	invoke() { eval '"_$@"'; }
	prehook() { invoke "$@"; }
	for i in setup flag param option disp msg; do
		eval "$i() { prehook $i \"\$@\"; }"
	done
	args() {
		on=$_on no=$_no export=$_export init=$_init _hasarg=$1 && shift
		while loop "$@" && shift; do
			case $1 in
				-?) [ "$_hasarg" ] && _opts="$_opts${1#-}" || _flags="$_flags${1#-}" ;;
				+?) _plus=1 _nflags="$_nflags${1#+}" ;;
				[!-+]*) kv "$1"
			esac
		done
	}
	defvar() {
		case $init in
			@none) : ;;
			@export) code "$1" _0 "export $1" ;;
			@empty) code "$1" _0 "${export:+export }$1=''" ;;
			@unset) code "$1" _0 "unset $1 ||:" "unset OPTARG ||:; ${1#:}" ;;
			*)
				case $init in @*) eval "init=\"=\${${init#@}}\""; esac
				case $init in [!=]*) _0 "$init"; return 0; esac
				quote init "${init#=}"
				code "$1" _0 "${export:+export }$1=$init" "OPTARG=$init; ${1#:}"
		esac
	}
	_setup() {
		[ "${1#-}" ] && _rest=$1
		while loop "$@" && shift; do kv "$1" _; done
	}
	_flag() { args '' "$@"; defvar "$@"; }
	_param() { args 1 "$@"; defvar "$@"; }
	_option() { args 1 "$@"; defvar "$@"; }
	_disp() { args '' "$@"; }
	_msg() { args '' _ "$@"; }
	cmd() { _mode=@ _cmds="$_cmds${_cmds:+|}'$1'"; }
	"$@"
	cmd() { :; }
	_0 "${_rest:?}=''"
	_0 "${_def:-$2}() {"
	_1 'OPTIND=$(($#+1))'
	_1 'while OPTARG= && [ $# -gt 0 ]; do'
	[ "$_abbr" ] && getoptions_abbr "$@"
	args() {
		sw='' validate='' pattern='' counter='' on=$_on no=$_no export=$_export
		while loop "$@" && shift; do
			case $1 in
				--\{no-\}*) i=${1#--?no-?}; sw "'--$i'|'--no-$i'" ;;
				--with\{out\}-*) i=${1#--*-}; sw "'--with-$i'|'--without-$i'" ;;
				[-+]? | --*) sw "'$1'" ;;
				*) kv "$1"
			esac
		done
		quote on "$on"
		quote no "$no"
	}
	setup() { :; }
	_flag() {
		args "$@"
		[ "$counter" ] && on=1 no=-1 v="\$((\${$1:-0}+\$OPTARG))" || v=''
		_3 "$sw)"
		_4 '[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break'
		_4 "eval '[ \${OPTARG+x} ] &&:' && OPTARG=$on || OPTARG=$no"
		valid "$1" "${v:-\$OPTARG}"
		_4 ';;'
	}
	_param() {
		args "$@"
		_3 "$sw)"
		_4 '[ $# -le 1 ] && set "required" "$1" && break'
		_4 'OPTARG=$2'
		valid "$1" '$OPTARG'
		_4 'shift ;;'
	}
	_option() {
		args "$@"
		_3 "$sw)"
		_4 'set -- "$1" "$@"'
		_4 '[ ${OPTARG+x} ] && {'
		_5 'case $1 in --no-*|--without-*) set "noarg" "${1%%\=*}"; break; esac'
		_5 '[ "${OPTARG:-}" ] && { shift; OPTARG=$2; } ||' "OPTARG=$on"
		_4 "} || OPTARG=$no"
		valid "$1" '$OPTARG'
		_4 'shift ;;'
	}
	valid() {
		set -- "$validate" "$pattern" "$1" "$2"
		[ "$1" ] && _4 "$1 || { set -- ${1%% *}:\$? \"\$1\" $1; break; }"
		[ "$2" ] && {
			_4 "case \$OPTARG in $2) ;;"
			_5 '*) set "pattern:'"$2"'" "$1"; break'
			_4 "esac"
		}
		code "$3" _4 "${export:+export }$3=\"$4\"" "${3#:}"
	}
	_disp() {
		args "$@"
		_3 "$sw)"
		code "$1" _4 "echo \"\${$1}\"" "${1#:}"
		_4 'exit 0 ;;'
	}
	_msg() { :; }
	[ "$_alt" ] && _2 'case $1 in -[!-]?*) set -- "-$@"; esac'
	_2 'case $1 in'
	_wa() { _4 "eval 'set -- $1' \${1+'\"\$@\"'}"; }
	_op() {
		_3 "$1) OPTARG=\$1; shift"
		_wa '"${OPTARG%"${OPTARG#??}"}" '"$2"'"${OPTARG#??}"'
		_4 "$3"
	}
	_3 '--?*=*) OPTARG=$1; shift'
	_wa '"${OPTARG%%\=*}" "${OPTARG#*\=}"'
	_4 ';;'
	_3 '--no-*|--without-*) unset OPTARG ;;'
	[ "$_alt" ] || {
		[ "$_opts" ] && _op "-[$_opts]?*" '' ';;'
		[ ! "$_flags" ] || _op "-[$_flags]?*" - 'OPTARG= ;;'
	}
	[ "$_plus" ] && {
		[ "$_nflags" ] && _op "+[$_nflags]?*" + 'unset OPTARG ;;'
		_3 '+*) unset OPTARG ;;'
	}
	_2 'esac'
	_2 'case $1 in'
	"$@"
	rest() {
		_4 'while [ $# -gt 0 ]; do'
		_5 "$_rest=\"\${$_rest}" '\"\${$(($OPTIND-$#))}\""'
		_5 'shift'
		_4 'done'
		_4 'break ;;'
	}
	_3 '--)'
	[ "$_mode" = @ ] || _4 'shift'
	rest
	_3 "[-${_plus:++}]?*)" 'set "unknown" "$1"; break ;;'
	_3 '*)'
	case $_mode in
		@)
			_4 "case \$1 in ${_cmds:-*}) ;;"
			_5 '*) set "notcmd" "$1"; break'
			_4 'esac'
			rest ;;
		+) rest ;;
		*) _4 "$_rest=\"\${$_rest}" '\"\${$(($OPTIND-$#))}\""'
	esac
	_2 'esac'
	_2 'shift'
	_1 'done'
	_1 '[ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }'
	_1 'case $1 in'
	_2 'unknown) set "Unrecognized option: $2" "$@" ;;'
	_2 'noarg) set "Does not allow an argument: $2" "$@" ;;'
	_2 'required) set "Requires an argument: $2" "$@" ;;'
	_2 'pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;'
	_2 'notcmd) set "Not a command: $2" "$@" ;;'
	_2 '*) set "Validation error ($1): $2" "$@"'
	_1 'esac'
	[ "$_error" ] && _1 "$_error" '"$@" >&2 || exit $?'
	_1 'echo "$1" >&2'
	_1 'exit 1'
	_0 '}'
	[ "$_help" ] && eval "shift 2; getoptions_help $1 $_help" ${3+'"$@"'}
	[ "$_def" ] && _0 "eval $_def \${1+'\"\$@\"'}; eval set -- \"\${$_rest}\""
	_0 '# Do not execute' # exit 1
}
# [getoptions_abbr] License: Creative Commons Zero v1.0 Universal
# https://github.com/ko1nksm/getoptions (v3.3.0)
getoptions_abbr() {
	abbr() {
		_3 "case '$1' in"
		_4 '"$1") OPTARG=; break ;;'
		_4 '$1*) OPTARG="$OPTARG '"$1"'"'
		_3 'esac'
	}
	args() {
		abbr=1
		shift
		for i; do
			case $i in
				--) break ;;
				[!-+]*) eval "${i%%:*}=\${i#*:}"
			esac
		done
		[ "$abbr" ] || return 0
		for i; do
			case $i in
				--) break ;;
				--\{no-\}*) abbr "--${i#--\{no-\}}"; abbr "--no-${i#--\{no-\}}" ;;
				--*) abbr "$i"
			esac
		done
	}
	setup() { :; }
	for i in flag param option disp; do
		eval "_$i()" '{ args "$@"; }'
	done
	msg() { :; }
	_2 'set -- "${1%%\=*}" "${1#*\=}" "$@"'
	[ "$_alt" ] && _2 'case $1 in -[!-]?*) set -- "-$@"; esac'
	_2 'while [ ${#1} -gt 2 ]; do'
	_3 'case $1 in (*[!a-zA-Z0-9_-]*) break; esac'
	"$@"
	_3 'break'
	_2 'done'
	_2 'case ${OPTARG# } in'
	_3 '*\ *)'
	_4 'eval "set -- $OPTARG $1 $OPTARG"'
	_4 'OPTIND=$((($#+1)/2)) OPTARG=$1; shift'
	_4 'while [ $# -gt "$OPTIND" ]; do OPTARG="$OPTARG, $1"; shift; done'
	_4 'set "Ambiguous option: $1 (could be $OPTARG)" ambiguous "$@"'
	[ "$_error" ] && _4 "$_error" '"$@" >&2 || exit $?'
	_4 'echo "$1" >&2'
	_4 'exit 1 ;;'
	_3 '?*)'
	_4 '[ "$2" = "$3" ] || OPTARG="$OPTARG=$2"'
	_4 "shift 3; eval 'set -- \"\${OPTARG# }\"' \${1+'\"\$@\"'}; OPTARG= ;;"
	_3 '*) shift 2'
	_2 'esac'
}
# [getoptions_help] License: Creative Commons Zero v1.0 Universal
# https://github.com/ko1nksm/getoptions (v3.3.0)
getoptions_help() {
	_width='30,12' _plus='' _leading='  '
	pad() { p=$2; while [ ${#p} -lt "$3" ]; do p="$p "; done; eval "$1=\$p"; }
	kv() { eval "${2-}${1%%:*}=\${1#*:}"; }
	sw() { pad sw "$sw${sw:+, }" "$1"; sw="$sw$2"; }
	args() {
		_type=$1 var=${2%% *} sw='' label='' hidden='' && shift 2
		while [ $# -gt 0 ] && i=$1 && shift && [ "$i" != -- ]; do
			case $i in
				--*) sw $((${_plus:+4}+4)) "$i" ;;
				-?) sw 0 "$i" ;;
				+?) [ ! "$_plus" ] || sw 4 "$i" ;;
				*) [ "$_type" = setup ] && kv "$i" _; kv "$i"
			esac
		done
		[ "$hidden" ] && return 0 || len=${_width%,*}
		[ "$label" ] || case $_type in
			setup | msg) label='' len=0 ;;
			flag | disp) label="$sw " ;;
			param) label="$sw $var " ;;
			option) label="${sw}[=$var] "
		esac
		[ "$_type" = cmd ] && label=${label:-$var } len=${_width#*,}
		pad label "${label:+$_leading}$label" "$len"
		[ ${#label} -le "$len" ] && [ $# -gt 0 ] && label="$label$1" && shift
		echo "$label"
		pad label '' "$len"
		for i; do echo "$label$i"; done
	}
	for i in setup flag param option disp 'msg -' cmd; do
		eval "${i% *}() { args $i \"\$@\"; }"
	done
	echo "$2() {"
	echo "cat<<'GETOPTIONSHERE'"
	"$@"
	echo "GETOPTIONSHERE"
	echo "}"
}
global() {
  if [ -z "$1" ]; then
    cat <<'EMBED'
inject file VERSION
EMBED
  else
    case "$1" in
      VERSION)
        cat <<'EMBED'
Mush v0.2.0 (2025-05-17 develop)

EMBED
        ;;
      *)
        echo ": "
        ;;
    esac
  fi
}
## BP005: Execute the entrypoint
main "$@"
